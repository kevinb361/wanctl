---
phase: 26-steering-state-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/steering/health.py
  - tests/test_steering_health.py
autonomous: true

must_haves:
  truths:
    - "Health response includes steering_enabled boolean field"
    - "Health response includes current congestion state (string + numeric)"
    - "Health response includes confidence scores when enabled"
    - "Health response includes last_decision_timestamp in ISO 8601"
    - "Health response includes timers (time_in_state_seconds, cycles_since_decision)"
    - "Health response includes error_counts for monitoring"
    - "Health response includes daemon PID and mode"
  artifacts:
    - path: "src/wanctl/steering/health.py"
      provides: "Extended health response with steering fields"
      contains: "steering_enabled"
    - path: "tests/test_steering_health.py"
      provides: "Tests for steering-specific response fields"
      min_lines: 280
  key_links:
    - from: "SteeringHealthHandler._get_health_status"
      to: "SteeringDaemon state dict"
      via: "self.daemon.state_mgr.state access"
      pattern: "self\\.daemon\\.state_mgr\\.state"
---

<objective>
Extend steering health endpoint response with live steering state fields.

Purpose: Enable monitoring systems to observe steering behavior (STEER-01 through STEER-05)
Output: Health response includes steering_enabled, congestion states, confidence, timers, errors
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-steering-state-integration/26-CONTEXT.md
@src/wanctl/steering/health.py
@src/wanctl/steering/daemon.py
@src/wanctl/health_check.py
@tests/test_steering_health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend health response with steering state fields</name>
  <files>src/wanctl/steering/health.py</files>
  <action>
Modify `_get_health_status()` method to include steering-specific fields when daemon is available:

1. Add imports: `from datetime import datetime, timezone`

2. Add helper function `_format_iso_timestamp(ts: float | None) -> str | None` that converts monotonic timestamps to ISO 8601 strings (use `datetime.now(timezone.utc).isoformat()` for current time, calculate offset for past events)

3. When `self.daemon` is not None, extract from `self.daemon.state_mgr.state`:

**Core steering state (STEER-01, STEER-02):**
```python
"steering": {
    "enabled": state["current_state"] != self.daemon.config.state_good,
    "state": state["current_state"],  # e.g., "SPECTRUM_GOOD" or "SPECTRUM_DEGRADED"
    "mode": "dry_run" if self.daemon.config.confidence_config and
            self.daemon.config.confidence_config.get("dry_run", {}).get("enabled") else "active",
}
```

**Congestion states (STEER-03, STEER-04):**
```python
"congestion": {
    "primary": {
        "state": state.get("congestion_state", "UNKNOWN"),
        "state_code": _congestion_state_code(state.get("congestion_state")),  # GREEN=0, YELLOW=1, RED=2
    },
    # secondary WAN congestion is not tracked by steering daemon - omit
}
```

Add helper `_congestion_state_code(state: str) -> int` returning 0/1/2/3 for GREEN/YELLOW/RED/UNKNOWN.

**Decision info (STEER-05):**
```python
"decision": {
    "last_transition_time": _format_iso_timestamp(state.get("last_transition_time")),
    "time_in_state_seconds": round(time.monotonic() - state.get("last_transition_time", start_time), 1),
}
```

**Timers and counters:**
```python
"counters": {
    "red_count": state.get("red_count", 0),
    "good_count": state.get("good_count", 0),
    "cake_read_failures": state.get("cake_read_failures", 0),
}
```

**Confidence scores (STEER-02, when enabled):**
```python
if self.daemon.confidence_controller:
    health["confidence"] = {
        "primary": round(self.daemon.confidence_controller.confidence_score, 1),
        # secondary, combined not applicable to steering daemon
    }
```

**Error counts:**
```python
"errors": {
    "consecutive_failures": self.consecutive_failures,
    "cake_read_failures": state.get("cake_read_failures", 0),
}
```

**System info:**
```python
"pid": os.getpid()  # Add `import os` at top
```

**Config thresholds (as requested by user):**
```python
"thresholds": {
    "green_rtt_ms": self.daemon.config.green_rtt_ms,
    "yellow_rtt_ms": self.daemon.config.yellow_rtt_ms,
    "red_rtt_ms": self.daemon.config.red_rtt_ms,
    "red_samples_required": self.daemon.config.red_samples_required,
    "green_samples_required": self.daemon.config.green_samples_required,
}
```

4. Match autorate health endpoint pattern for field naming consistency (snake_case, nested objects)

5. Handle cold start gracefully: if daemon.state_mgr.state is empty, return partial response with `"status": "starting"` and 503 status code
  </action>
  <verify>
Run: `.venv/bin/python -c "from wanctl.steering.health import SteeringHealthHandler; print('Import OK')"`
Verify no syntax errors.
  </verify>
  <done>
Health response includes all STEER-* fields when daemon is attached:
- steering.enabled (bool), steering.state (str), steering.mode (str)
- congestion.primary.state (str), congestion.primary.state_code (int)
- decision.last_transition_time (ISO 8601), decision.time_in_state_seconds (float)
- counters.red_count, counters.good_count, counters.cake_read_failures
- confidence.primary (float, when enabled)
- errors.consecutive_failures, errors.cake_read_failures
- thresholds.* (config values)
- pid (int)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for steering-specific response fields</name>
  <files>tests/test_steering_health.py</files>
  <action>
Add new test class `TestSteeringHealthResponseFields` with tests:

1. Create mock daemon fixture:
```python
@pytest.fixture
def mock_daemon():
    """Create a mock SteeringDaemon with realistic state."""
    daemon = MagicMock()
    daemon.config.state_good = "SPECTRUM_GOOD"
    daemon.config.state_degraded = "SPECTRUM_DEGRADED"
    daemon.config.confidence_config = None  # Disabled by default
    daemon.config.green_rtt_ms = 5.0
    daemon.config.yellow_rtt_ms = 15.0
    daemon.config.red_rtt_ms = 15.0
    daemon.config.red_samples_required = 2
    daemon.config.green_samples_required = 15
    daemon.confidence_controller = None
    daemon.state_mgr.state = {
        "current_state": "SPECTRUM_GOOD",
        "congestion_state": "GREEN",
        "red_count": 0,
        "good_count": 5,
        "cake_read_failures": 0,
        "last_transition_time": time.monotonic() - 60,  # 60s ago
    }
    return daemon
```

2. Test cases:
- `test_steering_enabled_false_when_good` - steering.enabled=False when state=GOOD
- `test_steering_enabled_true_when_degraded` - steering.enabled=True when state=DEGRADED
- `test_congestion_state_fields` - congestion.primary.state and state_code present
- `test_congestion_state_codes` - GREEN=0, YELLOW=1, RED=2, UNKNOWN=3
- `test_decision_timestamp_iso8601` - last_transition_time is valid ISO 8601
- `test_time_in_state_positive` - time_in_state_seconds > 0
- `test_counters_present` - counters.red_count, good_count, cake_read_failures
- `test_thresholds_from_config` - thresholds match daemon.config values
- `test_pid_present` - pid field is integer > 0
- `test_confidence_when_enabled` - confidence.primary present when controller active
- `test_confidence_absent_when_disabled` - confidence key absent when controller None
- `test_errors_field` - errors.consecutive_failures, errors.cake_read_failures

Each test should:
- Start server with `start_steering_health_server(daemon=mock_daemon)`
- Make HTTP request to health endpoint
- Assert expected fields and values
- Shutdown server in finally block

Add `from unittest.mock import MagicMock` import at top.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_steering_health.py -v`
All existing tests pass, new tests pass.
  </verify>
  <done>
12 new tests covering steering response fields:
- steering.enabled, steering.state, steering.mode
- congestion.primary.state, congestion.primary.state_code
- decision.last_transition_time, decision.time_in_state_seconds
- counters.*, thresholds.*, confidence.*, errors.*, pid
  </done>
</task>

</tasks>

<verification>
1. All existing tests still pass: `.venv/bin/pytest tests/test_steering_health.py -v`
2. Type checking passes: `.venv/bin/mypy src/wanctl/steering/health.py`
3. Linting passes: `.venv/bin/ruff check src/wanctl/steering/health.py tests/test_steering_health.py`
</verification>

<success_criteria>
- Health response includes all STEER-01 through STEER-05 fields when daemon attached
- Field naming matches autorate health endpoint convention (snake_case, nested)
- 12+ new tests for steering response fields
- All 22+ tests pass
- Type checking and linting pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-steering-state-integration/26-01-SUMMARY.md`
</output>
