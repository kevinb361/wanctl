---
phase: 26-steering-state-integration
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/wanctl/steering/daemon.py
  - tests/test_steering_health.py
autonomous: true

must_haves:
  truths:
    - "Health server starts during daemon initialization (INTG-01)"
    - "Health server stops during daemon shutdown (INTG-02)"
    - "Health status reflects current daemon state (INTG-03)"
    - "Startup failure logs and continues (daemon not blocked)"
    - "Mid-run health server crash is logged (daemon continues)"
  artifacts:
    - path: "src/wanctl/steering/daemon.py"
      provides: "Health server lifecycle wiring"
      contains: "start_steering_health_server"
    - path: "tests/test_steering_health.py"
      provides: "Integration tests for lifecycle"
      min_lines: 350
  key_links:
    - from: "daemon.py main()"
      to: "start_steering_health_server()"
      via: "called after SteeringDaemon creation"
      pattern: "health_server.*=.*start_steering_health_server"
    - from: "daemon.py finally block"
      to: "health_server.shutdown()"
      via: "cleanup in finally"
      pattern: "health_server\\.shutdown\\(\\)"
---

<objective>
Wire health server into steering daemon lifecycle.

Purpose: Enable health monitoring during daemon operation (INTG-01 through INTG-03)
Output: Health server starts at daemon init, stops at shutdown, reflects live state
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-steering-state-integration/26-CONTEXT.md
@.planning/phases/26-steering-state-integration/26-01-SUMMARY.md
@src/wanctl/steering/daemon.py
@src/wanctl/steering/health.py
@tests/test_steering_health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire health server into daemon lifecycle</name>
  <files>src/wanctl/steering/daemon.py</files>
  <action>
1. Add import at top of file:
```python
from .health import start_steering_health_server, update_steering_health_status
```

2. After daemon creation (~line 1457, after `daemon = SteeringDaemon(...)`), add:
```python
# Start health server (INTG-01)
health_server = None
try:
    health_server = start_steering_health_server(
        host="127.0.0.1",
        port=9102,
        daemon=daemon,
    )
except Exception as e:
    # Log and continue - health endpoint is optional
    logger.warning(f"Failed to start health server: {e}")
```

3. In `run_daemon_loop()`, after `cycle_success = daemon.run_cycle()`, add status update call:
```python
# Update health server with current failure state (INTG-03)
update_steering_health_status(consecutive_failures)
```

4. In the finally block (~line 1478), add shutdown before lock release:
```python
# Shutdown health server (INTG-02)
if health_server is not None:
    try:
        health_server.shutdown()
        logger.debug("Health server stopped")
    except Exception as e:
        logger.warning(f"Error shutting down health server: {e}")
```

5. Pass health_server to run_daemon_loop or make it accessible:

Option A (simpler): Use nonlocal variable pattern
Option B (cleaner): Return health_server from main() setup and pass to run_daemon_loop

Choose Option A for minimal changes:
- Define `health_server = None` before try block
- After start, it's either the server or None
- Finally block checks `if health_server is not None`
  </action>
  <verify>
Run: `.venv/bin/python -c "from wanctl.steering.daemon import main; print('Import OK')"`
Verify no syntax errors.
  </verify>
  <done>
Health server lifecycle wired:
- Starts after SteeringDaemon creation (port 9102)
- Startup failure logs warning, daemon continues
- consecutive_failures updated each cycle
- Shutdown called in finally block before lock release
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lifecycle integration tests</name>
  <files>tests/test_steering_health.py</files>
  <action>
Add new test class `TestSteeringHealthLifecycle` with tests:

1. `test_health_server_receives_daemon_reference`:
   - Create mock daemon
   - Start server with daemon=mock_daemon
   - Verify SteeringHealthHandler.daemon is set
   - Shutdown server

2. `test_health_status_updates_with_failures`:
   - Start server
   - update_steering_health_status(0) -> healthy
   - update_steering_health_status(3) -> degraded
   - update_steering_health_status(0) -> healthy again
   - Verify HTTP responses reflect changes

3. `test_health_server_graceful_shutdown`:
   - Start server
   - Verify thread is alive
   - shutdown()
   - Verify thread is not alive within 1s
   - Verify port is free (optional: try to bind)

4. `test_concurrent_requests_during_update`:
   - Start server with mock daemon
   - Use threading to make requests while updating status
   - Verify no crashes, responses are valid JSON

5. `test_health_reflects_daemon_state_changes`:
   - Start server with mock daemon
   - Set daemon.state_mgr.state["current_state"] = "SPECTRUM_GOOD"
   - Request -> steering.enabled=False
   - Set daemon.state_mgr.state["current_state"] = "SPECTRUM_DEGRADED"
   - Request -> steering.enabled=True

6. `test_daemon_none_returns_minimal_response`:
   - Start server with daemon=None
   - Request -> response has status, uptime, version
   - Response does NOT have steering, congestion, decision keys

These tests verify INTG-03 (state updates reflect in health).
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_steering_health.py -v`
All tests pass.
  </verify>
  <done>
6 new lifecycle integration tests:
- daemon reference passed correctly
- status updates reflected in HTTP responses
- graceful shutdown works
- concurrent access is safe
- daemon state changes reflected
- minimal response when daemon=None
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify</name>
  <files></files>
  <action>
Run full test suite to ensure no regressions:
```bash
.venv/bin/pytest tests/ -v --tb=short
```

Run type checking:
```bash
.venv/bin/mypy src/wanctl/steering/daemon.py src/wanctl/steering/health.py
```

Run linting:
```bash
.venv/bin/ruff check src/wanctl/steering/ tests/test_steering_health.py
.venv/bin/ruff format --check src/wanctl/steering/ tests/test_steering_health.py
```

Fix any issues found.
  </action>
  <verify>
All commands exit with code 0.
  </verify>
  <done>
Full test suite passes (700+ tests), type checking clean, linting clean.
  </done>
</task>

</tasks>

<verification>
1. Health endpoint accessible when daemon running: Verified by integration test
2. Health endpoint stops when daemon stops: Verified by shutdown test
3. State changes reflected: Verified by state change test
4. Full test suite: `.venv/bin/pytest tests/ -v` (700+ tests pass)
5. Type/lint clean: mypy and ruff pass
</verification>

<success_criteria>
- INTG-01: Health server starts during daemon init
- INTG-02: Health server stops during daemon shutdown
- INTG-03: Health status reflects current daemon state
- 6+ new lifecycle integration tests
- 28+ total steering health tests pass
- Full test suite passes (700+ tests)
- Type checking and linting pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-steering-state-integration/26-02-SUMMARY.md`
</output>
