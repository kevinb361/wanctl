---
phase: 40-cli-tool
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/storage/reader.py
  - src/wanctl/storage/__init__.py
  - pyproject.toml
  - tests/test_metrics_reader.py
autonomous: true

must_haves:
  truths:
    - "Metrics can be queried by time range"
    - "Metrics can be filtered by metric name"
    - "Summary statistics (min/max/avg/percentiles) can be computed"
    - "Empty queries return empty results without error"
  artifacts:
    - path: "src/wanctl/storage/reader.py"
      provides: "MetricsReader class with query and summary functions"
      exports: ["MetricsReader", "query_metrics", "compute_summary"]
    - path: "tests/test_metrics_reader.py"
      provides: "Reader unit tests"
      min_lines: 80
  key_links:
    - from: "src/wanctl/storage/reader.py"
      to: "sqlite3"
      via: "read-only database connection"
      pattern: "sqlite3\\.connect.*mode=ro"
    - from: "src/wanctl/storage/reader.py"
      to: "statistics.quantiles"
      via: "percentile calculation"
      pattern: "quantiles\\("
---

<objective>
Create MetricsReader module for querying stored metrics from SQLite.

Purpose: Provide query layer that CLI (Plan 02) and API (Phase 41) will use.
Output: `src/wanctl/storage/reader.py` with query_metrics(), compute_summary(), and unit tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-cli-tool/40-CONTEXT.md
@.planning/phases/40-cli-tool/40-RESEARCH.md
@src/wanctl/storage/writer.py
@src/wanctl/storage/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetricsReader with query functions</name>
  <files>
    src/wanctl/storage/reader.py
    src/wanctl/storage/__init__.py
    pyproject.toml
  </files>
  <action>
Create `src/wanctl/storage/reader.py` with:

1. **query_metrics() function:**
   - Takes: db_path, start_ts (int), end_ts (int), metrics (list[str] | None), wan (str | None), granularity (str | None)
   - Opens read-only connection: `sqlite3.connect(f"file:{db_path}?mode=ro", uri=True)`
   - Query: SELECT timestamp, wan_name, metric_name, value, labels, granularity FROM metrics WHERE timestamp BETWEEN ? AND ?
   - Add optional filters for metric_name IN (...) and wan_name = ?
   - Return list[dict] with dict(row) for each result
   - Handle missing database gracefully (return empty list, don't raise)

2. **compute_summary() function:**
   - Takes: values (list[float]) -> dict with min, max, avg, p50, p95, p99
   - Use statistics.mean() and statistics.quantiles()
   - Handle empty list (return empty dict)
   - Handle single value (return that value for all stats)
   - Use n=100 for quantiles to get percentiles 1-99, then extract p50=[49], p95=[94], p99=[98]

3. **Auto-granularity selection:**
   - Function: select_granularity(start_ts, end_ts) -> str
   - Logic per RESEARCH.md: <6h = "raw", <24h = "1m", <7d = "5m", else "1h"

4. **Add tabulate to pyproject.toml dependencies:**
   ```toml
   dependencies = [
     "requests>=2.31.0",
     "pyyaml>=6.0.1",
     "paramiko>=3.4.0",
     "pexpect>=4.9.0",
     "tabulate>=0.9.0",  # ADD THIS
   ]
   ```

5. **Update storage/__init__.py:**
   - Export query_metrics, compute_summary, select_granularity from reader

Note: Use DEFAULT_DB_PATH from writer.py, don't duplicate the constant.
  </action>
  <verify>
`.venv/bin/python -c "from wanctl.storage import query_metrics, compute_summary, select_granularity; print('Imports OK')"`
  </verify>
  <done>
Reader module exports query_metrics(), compute_summary(), select_granularity() with proper signatures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add reader unit tests</name>
  <files>tests/test_metrics_reader.py</files>
  <action>
Create comprehensive tests for MetricsReader in `tests/test_metrics_reader.py`:

1. **query_metrics tests:**
   - test_query_returns_empty_list_when_db_missing
   - test_query_returns_empty_list_when_no_data_in_range
   - test_query_filters_by_time_range
   - test_query_filters_by_metric_names
   - test_query_filters_by_wan_name
   - test_query_filters_by_granularity
   - test_query_combined_filters (time + metric + wan)
   - test_query_returns_all_columns (timestamp, wan_name, metric_name, value, labels, granularity)

2. **compute_summary tests:**
   - test_summary_empty_list_returns_empty_dict
   - test_summary_single_value
   - test_summary_two_values (edge case for quantiles)
   - test_summary_many_values_correct_stats
   - test_summary_includes_all_keys (min, max, avg, p50, p95, p99)

3. **select_granularity tests:**
   - test_granularity_under_6h_returns_raw
   - test_granularity_under_24h_returns_1m
   - test_granularity_under_7d_returns_5m
   - test_granularity_over_7d_returns_1h

Use pytest fixtures:
- tmp_path for temporary database
- Create test data via MetricsWriter (use _reset_instance() for isolation)

Test data should include:
- Multiple WANs (spectrum, att)
- Multiple metrics (wanctl_rtt_ms, wanctl_rate_download_mbps, wanctl_state)
- Multiple timestamps spanning test ranges
- Different granularities (raw, 1m)
  </action>
  <verify>`.venv/bin/pytest tests/test_metrics_reader.py -v`</verify>
  <done>All reader tests pass. Coverage for query_metrics, compute_summary, select_granularity.</done>
</task>

</tasks>

<verification>
```bash
# All imports work
.venv/bin/python -c "from wanctl.storage import query_metrics, compute_summary, select_granularity"

# Tests pass
.venv/bin/pytest tests/test_metrics_reader.py -v

# tabulate installed
.venv/bin/python -c "import tabulate; print(f'tabulate {tabulate.__version__}')"
```
</verification>

<success_criteria>
- query_metrics() returns list[dict] filtered by time/metric/wan/granularity
- compute_summary() returns dict with min/max/avg/p50/p95/p99
- select_granularity() auto-selects based on time range
- Empty/missing database handled gracefully (no crashes)
- All tests pass
- tabulate dependency added
</success_criteria>

<output>
After completion, create `.planning/phases/40-cli-tool/40-01-SUMMARY.md`
</output>
