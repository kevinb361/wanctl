---
phase: 21-critical-safety-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_baseline_rtt_manager.py
  - tests/test_state_utils.py
autonomous: true

must_haves:
  truths:
    - "Test proves baseline RTT remains frozen during 100+ cycles of sustained load (delta > 3ms)"
    - "Test proves partial JSON file triggers graceful recovery with default value"
    - "Test proves truncated JSON (simulating interrupted write) returns default, logs error"
  artifacts:
    - path: "tests/test_baseline_rtt_manager.py"
      provides: "Baseline freeze safety invariant tests"
      contains: "test_baseline_frozen_sustained_load"
    - path: "tests/test_state_utils.py"
      provides: "State corruption recovery tests"
      contains: "test_partial_json_returns_default"
  key_links:
    - from: "tests/test_baseline_rtt_manager.py"
      to: "src/wanctl/baseline_rtt_manager.py"
      via: "imports BaselineRTTManager"
      pattern: "from wanctl.baseline_rtt_manager import"
    - from: "tests/test_state_utils.py"
      to: "src/wanctl/state_utils.py"
      via: "imports safe_json_load_file"
      pattern: "from wanctl.state_utils import"
---

<objective>
Add explicit safety invariant tests for baseline RTT freeze (TEST-01) and state file corruption recovery (TEST-02).

Purpose: Prove architectural safety invariants hold under stress conditions. Existing code handles these cases but lacks explicit tests proving the safety properties.

Output: Two test files with safety invariant tests that document and verify critical system behaviors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-critical-safety-tests/21-RESEARCH.md

# Source files being tested
@src/wanctl/baseline_rtt_manager.py
@src/wanctl/state_utils.py

# Existing test patterns
@tests/test_wan_controller.py (lines 895-925 for baseline freeze pattern)
@tests/test_state_utils.py (existing tests for safe_read_json)
@tests/conftest.py (temp_dir fixture)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add baseline RTT freeze sustained load test (TEST-01)</name>
  <files>tests/test_baseline_rtt_manager.py</files>
  <action>
Create or extend test file for BaselineRTTManager with explicit sustained load safety test:

```python
class TestBaselineFreezeInvariant:
    """Tests proving baseline RTT freezing invariant under sustained load.

    ARCHITECTURAL INVARIANT: Baseline RTT must not drift when delta > threshold.
    This prevents baseline from chasing load, which would mask true congestion.
    """

    def test_baseline_frozen_sustained_load(self):
        """Baseline MUST remain frozen during 100+ cycles of sustained load."""
        # Setup: initial baseline 20ms, threshold 3ms
        manager = BaselineRTTManager(
            initial_baseline=20.0,
            alpha_baseline=0.1,
            baseline_update_threshold=3.0,
            logger=mock_logger
        )

        # Run 100 cycles with delta consistently > 3ms (sustained load)
        for _ in range(100):
            # Simulate load: measured RTT 50ms, load RTT 45ms
            # Delta = 45 - 20 = 25ms (>> 3ms threshold)
            manager.update_baseline_ewma(measured_rtt=50.0, load_rtt=45.0)

        # INVARIANT: Baseline MUST NOT have drifted
        assert manager.baseline_rtt == pytest.approx(20.0, abs=0.01)
```

Additional tests to include:
- `test_baseline_frozen_at_exact_threshold`: delta = threshold exactly (edge case)
- `test_baseline_frozen_logs_debug`: verify "frozen (under load)" debug log
- `test_baseline_updates_only_when_idle`: verify updates resume when delta < threshold

Use existing mock_logger pattern from conftest or create inline MagicMock.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_baseline_rtt_manager.py -v`
Expected: All tests pass, including `test_baseline_frozen_sustained_load`
  </verify>
  <done>
TEST-01 complete: Test proves baseline RTT frozen during 100+ cycles with delta > 3ms
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state file corruption recovery tests (TEST-02)</name>
  <files>tests/test_state_utils.py</files>
  <action>
Extend tests/test_state_utils.py with explicit corruption recovery tests:

```python
class TestStateCorruptionRecovery:
    """Tests proving graceful recovery from state file corruption.

    SAFETY INVARIANT: Corrupted state files must return defaults, not crash.
    This prevents daemon failures during interrupted writes or disk corruption.
    """

    def test_partial_json_returns_default(self, temp_dir):
        """Truncated JSON (interrupted write) returns default, not crash."""
        file_path = temp_dir / "state.json"

        # Simulate interrupted write - missing closing braces
        with open(file_path, "w") as f:
            f.write('{"ewma": {"baseline_rtt": 30.0')  # Truncated

        result = safe_json_load_file(file_path, default={"initialized": True})
        assert result == {"initialized": True}  # Graceful recovery

    def test_truncated_json_logs_error(self, temp_dir, caplog):
        """Truncated JSON should log error message."""
        file_path = temp_dir / "state.json"

        with open(file_path, "w") as f:
            f.write('{"key": "value"')  # Missing closing brace

        logger = logging.getLogger("test")
        result = safe_json_load_file(
            file_path,
            logger=logger,
            default={},
            error_context="test state"
        )

        assert result == {}
        # Verify error was logged (check caplog or mock logger)
```

Additional tests to include:
- `test_binary_garbage_returns_default`: non-JSON binary content
- `test_utf8_decode_error_returns_default`: invalid UTF-8 bytes
- `test_empty_object_is_valid`: `{}` is valid, should return `{}`
- `test_null_content_returns_default`: file containing only `null`

Import safe_json_load_file if not already imported.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_state_utils.py -v -k corruption`
Expected: All corruption recovery tests pass
  </verify>
  <done>
TEST-02 complete: Tests prove truncated/corrupted JSON returns defaults gracefully
  </done>
</task>

</tasks>

<verification>
```bash
# Run all new safety tests
.venv/bin/pytest tests/test_baseline_rtt_manager.py tests/test_state_utils.py -v

# Verify test count increased
.venv/bin/pytest tests/ --collect-only | grep "test session starts" -A2
```
</verification>

<success_criteria>
- [ ] tests/test_baseline_rtt_manager.py has sustained load freeze test (100+ cycles)
- [ ] tests/test_state_utils.py has partial/truncated JSON recovery tests
- [ ] All tests pass: `.venv/bin/pytest tests/test_baseline_rtt_manager.py tests/test_state_utils.py -v`
- [ ] No regressions: `.venv/bin/pytest tests/ -v` (all 671+ tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/21-critical-safety-tests/21-01-SUMMARY.md`
</output>
