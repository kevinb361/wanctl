---
phase: 21-critical-safety-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/router_client.py
  - tests/test_router_client.py
autonomous: true

must_haves:
  truths:
    - "REST API failure automatically falls back to SSH transport"
    - "Failover is logged so operators know which transport is active"
    - "Test proves failover occurs when REST raises ConnectionError/Timeout"
  artifacts:
    - path: "src/wanctl/router_client.py"
      provides: "Transport failover wrapper"
      contains: "get_router_client_with_failover"
    - path: "tests/test_router_client.py"
      provides: "Transport failover tests"
      contains: "test_rest_failure_triggers_ssh_fallback"
  key_links:
    - from: "src/wanctl/router_client.py"
      to: "src/wanctl/routeros_rest.py"
      via: "imports RouterOSREST"
      pattern: "from wanctl.routeros_rest import"
    - from: "src/wanctl/router_client.py"
      to: "src/wanctl/routeros_ssh.py"
      via: "imports RouterOSSSH"
      pattern: "from wanctl.routeros_ssh import"
    - from: "tests/test_router_client.py"
      to: "src/wanctl/router_client.py"
      via: "imports get_router_client_with_failover"
      pattern: "from wanctl.router_client import"
---

<objective>
Implement REST-to-SSH automatic failover and add tests proving the safety behavior (TEST-03).

Purpose: Research found no automatic failover logic exists in router_client.py. REST API failures would crash the daemon. Implement failover wrapper then test it.

Output: Failover wrapper in router_client.py + comprehensive tests proving failover behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-critical-safety-tests/21-RESEARCH.md

# Source files
@src/wanctl/router_client.py
@src/wanctl/routeros_rest.py
@src/wanctl/routeros_ssh.py

# Existing test patterns
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transport failover wrapper</name>
  <files>src/wanctl/router_client.py</files>
  <action>
Add failover wrapper class to router_client.py that wraps REST client and falls back to SSH on failure:

```python
class FailoverRouterClient:
    """Router client wrapper with automatic REST-to-SSH failover.

    Wraps primary transport (REST) and falls back to secondary (SSH) on failure.
    Logs transport switches for operational visibility.

    Usage:
        client = get_router_client_with_failover(config, logger)
        rc, stdout, stderr = client.run_cmd("/queue tree print")
    """

    def __init__(
        self,
        config: Any,
        logger: logging.Logger,
        primary_transport: str = "rest",
        fallback_transport: str = "ssh",
    ):
        self.config = config
        self.logger = logger
        self.primary_transport = primary_transport
        self.fallback_transport = fallback_transport
        self._primary_client: RouterClient | None = None
        self._fallback_client: RouterClient | None = None
        self._using_fallback = False

    def _get_primary(self) -> RouterClient:
        """Get or create primary transport client."""
        if self._primary_client is None:
            self._primary_client = _create_transport(
                self.primary_transport, self.config, self.logger
            )
        return self._primary_client

    def _get_fallback(self) -> RouterClient:
        """Get or create fallback transport client."""
        if self._fallback_client is None:
            self.logger.warning(
                f"Creating fallback {self.fallback_transport} transport "
                f"(primary {self.primary_transport} failed)"
            )
            self._fallback_client = _create_transport(
                self.fallback_transport, self.config, self.logger
            )
        return self._fallback_client

    def run_cmd(self, cmd: str) -> tuple[int, str, str]:
        """Execute command with automatic failover."""
        if self._using_fallback:
            return self._get_fallback().run_cmd(cmd)

        try:
            return self._get_primary().run_cmd(cmd)
        except (ConnectionError, TimeoutError, OSError) as e:
            self.logger.warning(
                f"Primary transport ({self.primary_transport}) failed: {e}. "
                f"Switching to fallback ({self.fallback_transport})"
            )
            self._using_fallback = True
            return self._get_fallback().run_cmd(cmd)

    def close(self) -> None:
        """Close all transport connections."""
        if self._primary_client:
            self._primary_client.close()
        if self._fallback_client:
            self._fallback_client.close()


def _create_transport(transport: str, config: Any, logger: logging.Logger) -> RouterClient:
    """Create transport client by name."""
    if transport == "ssh":
        return RouterOSSSH.from_config(config, logger)
    elif transport == "rest":
        from wanctl.routeros_rest import RouterOSREST
        return RouterOSREST.from_config(config, logger)
    else:
        raise ValueError(f"Unsupported transport: {transport}")


def get_router_client_with_failover(
    config: Any,
    logger: logging.Logger,
    primary: str = "rest",
    fallback: str = "ssh",
) -> FailoverRouterClient:
    """Factory for router client with automatic failover.

    Args:
        config: Configuration object with router settings
        logger: Logger instance
        primary: Primary transport ("rest" or "ssh"), default "rest"
        fallback: Fallback transport ("rest" or "ssh"), default "ssh"

    Returns:
        FailoverRouterClient with automatic failover capability
    """
    return FailoverRouterClient(config, logger, primary, fallback)
```

Update `__all__` to export new functions:
```python
__all__ = ["get_router_client", "get_router_client_with_failover", "FailoverRouterClient", "RouterClient"]
```

Keep existing `get_router_client` unchanged (backward compatibility).
  </action>
  <verify>
Run: `.venv/bin/ruff check src/wanctl/router_client.py`
Run: `.venv/bin/mypy src/wanctl/router_client.py`
Expected: No errors
  </verify>
  <done>
Failover wrapper implemented with REST-to-SSH automatic switch on connection errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add transport failover tests (TEST-03)</name>
  <files>tests/test_router_client.py</files>
  <action>
Create tests/test_router_client.py with failover behavior tests:

```python
"""Tests for router_client module - transport selection and failover."""

import logging
from unittest.mock import MagicMock, patch

import pytest

from wanctl.router_client import (
    FailoverRouterClient,
    get_router_client,
    get_router_client_with_failover,
)


class TestGetRouterClient:
    """Tests for basic get_router_client factory."""

    def test_ssh_transport_selection(self):
        """SSH transport selected when config specifies ssh."""
        config = MagicMock()
        config.router_transport = "ssh"
        logger = MagicMock(spec=logging.Logger)

        with patch("wanctl.router_client.RouterOSSSH") as mock_ssh:
            mock_ssh.from_config.return_value = MagicMock()
            client = get_router_client(config, logger)
            mock_ssh.from_config.assert_called_once_with(config, logger)

    def test_rest_transport_selection(self):
        """REST transport selected when config specifies rest."""
        config = MagicMock()
        config.router_transport = "rest"
        logger = MagicMock(spec=logging.Logger)

        with patch("wanctl.router_client.RouterOSREST") as mock_rest:
            mock_rest.from_config.return_value = MagicMock()
            client = get_router_client(config, logger)
            mock_rest.from_config.assert_called_once_with(config, logger)

    def test_invalid_transport_raises(self):
        """Invalid transport raises ValueError."""
        config = MagicMock()
        config.router_transport = "invalid"
        logger = MagicMock(spec=logging.Logger)

        with pytest.raises(ValueError, match="Unsupported router transport"):
            get_router_client(config, logger)


class TestFailoverRouterClient:
    """Tests for FailoverRouterClient automatic failover behavior.

    SAFETY INVARIANT: REST API failure must automatically fall back to SSH.
    This prevents daemon crashes when REST API is temporarily unavailable.
    """

    @pytest.fixture
    def mock_config(self):
        return MagicMock()

    @pytest.fixture
    def mock_logger(self):
        return MagicMock(spec=logging.Logger)

    def test_rest_failure_triggers_ssh_fallback(self, mock_config, mock_logger):
        """REST API failure should trigger automatic SSH fallback."""
        # Setup: REST client that fails, SSH client that succeeds
        mock_rest = MagicMock()
        mock_rest.run_cmd.side_effect = ConnectionError("REST connection failed")

        mock_ssh = MagicMock()
        mock_ssh.run_cmd.return_value = (0, "output", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            # First call creates REST (fails), second creates SSH (succeeds)
            mock_create.side_effect = [mock_rest, mock_ssh]

            client = get_router_client_with_failover(mock_config, mock_logger)
            rc, stdout, stderr = client.run_cmd("/queue tree print")

            assert rc == 0
            assert stdout == "output"
            # Verify SSH was used as fallback
            mock_ssh.run_cmd.assert_called_once()
            # Verify warning was logged
            mock_logger.warning.assert_called()

    def test_timeout_triggers_fallback(self, mock_config, mock_logger):
        """TimeoutError should also trigger SSH fallback."""
        mock_rest = MagicMock()
        mock_rest.run_cmd.side_effect = TimeoutError("REST timeout")

        mock_ssh = MagicMock()
        mock_ssh.run_cmd.return_value = (0, "success", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            mock_create.side_effect = [mock_rest, mock_ssh]

            client = get_router_client_with_failover(mock_config, mock_logger)
            rc, stdout, stderr = client.run_cmd("/interface print")

            assert rc == 0
            mock_ssh.run_cmd.assert_called_once()

    def test_subsequent_calls_use_fallback(self, mock_config, mock_logger):
        """After failover, subsequent calls use fallback transport."""
        mock_rest = MagicMock()
        mock_rest.run_cmd.side_effect = ConnectionError("REST down")

        mock_ssh = MagicMock()
        mock_ssh.run_cmd.return_value = (0, "ok", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            mock_create.side_effect = [mock_rest, mock_ssh]

            client = get_router_client_with_failover(mock_config, mock_logger)

            # First call triggers failover
            client.run_cmd("/first")
            # Second call should use fallback directly
            client.run_cmd("/second")
            # Third call should also use fallback
            client.run_cmd("/third")

            # SSH should have been called 3 times
            assert mock_ssh.run_cmd.call_count == 3
            # REST should only have been tried once
            assert mock_rest.run_cmd.call_count == 1

    def test_primary_success_no_fallback(self, mock_config, mock_logger):
        """When primary succeeds, fallback is never created."""
        mock_rest = MagicMock()
        mock_rest.run_cmd.return_value = (0, "rest output", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            mock_create.return_value = mock_rest

            client = get_router_client_with_failover(mock_config, mock_logger)
            rc, stdout, stderr = client.run_cmd("/queue tree print")

            assert rc == 0
            assert stdout == "rest output"
            # Only one transport created (REST)
            assert mock_create.call_count == 1

    def test_close_closes_both_transports(self, mock_config, mock_logger):
        """close() should close both primary and fallback clients."""
        mock_rest = MagicMock()
        mock_rest.run_cmd.side_effect = ConnectionError("REST down")

        mock_ssh = MagicMock()
        mock_ssh.run_cmd.return_value = (0, "ok", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            mock_create.side_effect = [mock_rest, mock_ssh]

            client = get_router_client_with_failover(mock_config, mock_logger)
            client.run_cmd("/test")  # Triggers failover
            client.close()

            mock_rest.close.assert_called_once()
            mock_ssh.close.assert_called_once()

    def test_failover_logs_warning(self, mock_config, mock_logger):
        """Failover should log warning with transport names."""
        mock_rest = MagicMock()
        mock_rest.run_cmd.side_effect = ConnectionError("REST failed")

        mock_ssh = MagicMock()
        mock_ssh.run_cmd.return_value = (0, "ok", "")

        with patch("wanctl.router_client._create_transport") as mock_create:
            mock_create.side_effect = [mock_rest, mock_ssh]

            client = get_router_client_with_failover(mock_config, mock_logger)
            client.run_cmd("/test")

            # Verify warning mentions both transports
            warning_calls = [
                str(call) for call in mock_logger.warning.call_args_list
            ]
            assert any("rest" in call.lower() and "ssh" in call.lower()
                      for call in warning_calls)
```

Test file follows existing patterns (MagicMock, pytest fixtures, spec=logging.Logger).
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_router_client.py -v`
Expected: All tests pass, including `test_rest_failure_triggers_ssh_fallback`
  </verify>
  <done>
TEST-03 complete: Tests prove REST failure automatically triggers SSH fallback
  </done>
</task>

</tasks>

<verification>
```bash
# Run failover tests
.venv/bin/pytest tests/test_router_client.py -v

# Verify no regressions
.venv/bin/pytest tests/ -v

# Verify lint and type checks
.venv/bin/ruff check src/wanctl/router_client.py
.venv/bin/mypy src/wanctl/router_client.py
```
</verification>

<success_criteria>
- [ ] FailoverRouterClient class exists in router_client.py
- [ ] get_router_client_with_failover factory function exported
- [ ] tests/test_router_client.py has REST-to-SSH failover tests
- [ ] All tests pass: `.venv/bin/pytest tests/test_router_client.py -v`
- [ ] No regressions: `.venv/bin/pytest tests/ -v` (all 671+ tests pass)
- [ ] Lint clean: `.venv/bin/ruff check src/wanctl/router_client.py`
</success_criteria>

<output>
After completion, create `.planning/phases/21-critical-safety-tests/21-02-SUMMARY.md`
</output>
