---
phase: 39-data-recording
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/steering/daemon.py
  - src/wanctl/storage/config_snapshot.py
  - tests/test_steering_metrics_recording.py
  - tests/test_config_snapshot.py
autonomous: true

must_haves:
  truths:
    - "Steering daemon records RTT metrics each cycle"
    - "Steering daemon records steering state each cycle"
    - "Config snapshot saved on startup"
    - "Recording overhead is <5ms per cycle"
  artifacts:
    - path: "src/wanctl/steering/daemon.py"
      provides: "MetricsWriter integration in run_cycle"
      contains: "write_metrics_batch"
    - path: "src/wanctl/storage/config_snapshot.py"
      provides: "Config snapshot recording helper"
      exports: ["record_config_snapshot"]
    - path: "tests/test_steering_metrics_recording.py"
      provides: "Tests for steering metrics recording"
      min_lines: 80
    - path: "tests/test_config_snapshot.py"
      provides: "Tests for config snapshot functionality"
      min_lines: 50
  key_links:
    - from: "src/wanctl/steering/daemon.py"
      to: "wanctl.storage.MetricsWriter"
      via: "import and batch write in run_cycle"
      pattern: "from wanctl\\.storage import MetricsWriter"
    - from: "src/wanctl/steering/daemon.py"
      to: "record_config_snapshot"
      via: "import and call on startup"
      pattern: "record_config_snapshot"
---

<objective>
Integrate MetricsWriter into the steering daemon to record steering metrics each cycle, plus add config snapshot recording on startup.

Purpose: Complete the data recording layer by capturing steering decisions and initial configuration state. This enables historical analysis of steering behavior and debugging configuration drift.

Output: Modified steering/daemon.py with metrics recording, new config_snapshot.py module, and comprehensive tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-storage-foundation/38-02-SUMMARY.md
@src/wanctl/storage/__init__.py
@src/wanctl/storage/writer.py
@src/wanctl/steering/daemon.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metrics recording to SteeringDaemon.run_cycle</name>
  <files>src/wanctl/steering/daemon.py</files>
  <action>
Integrate MetricsWriter into the steering daemon:

1. Add import at top (near other wanctl imports):
   ```python
   from wanctl.storage import MetricsWriter
   from wanctl.config_base import get_storage_config
   ```

2. In SteeringDaemon.__init__, add storage initialization after other component setup:
   ```python
   # Metrics history storage (optional)
   storage_config = get_storage_config(config.data)
   self._metrics_writer: MetricsWriter | None = None
   if storage_config.get("db_path"):
       from pathlib import Path
       self._metrics_writer = MetricsWriter(Path(storage_config["db_path"]))
   ```

3. In SteeringDaemon.run_cycle, after the "Record steering metrics if enabled" block (around line 1228), add metrics batch write:
   ```python
   # Record to SQLite history (if storage enabled)
   if self._metrics_writer is not None:
       ts = int(time.time())
       steering_enabled_val = 1.0 if steering_enabled else 0.0
       state_val = {"GREEN": 0, "YELLOW": 1, "RED": 2}.get(congestion_state, 0)

       metrics_batch = [
           (ts, self.config.primary_wan, "wanctl_rtt_ms", current_rtt, None, "raw"),
           (ts, self.config.primary_wan, "wanctl_rtt_baseline_ms", baseline_rtt, None, "raw"),
           (ts, self.config.primary_wan, "wanctl_rtt_delta_ms", delta, None, "raw"),
           (ts, self.config.primary_wan, "wanctl_steering_enabled", steering_enabled_val, None, "raw"),
           (ts, self.config.primary_wan, "wanctl_state", float(state_val), {"source": "steering"}, "raw"),
       ]
       self._metrics_writer.write_metrics_batch(metrics_batch)
   ```

4. Add state transition recording with reason in execute_steering_transition:
   ```python
   # At end of execute_steering_transition, before return True:
   if self._metrics_writer is not None:
       ts = int(time.time())
       reason = f"Transitioned from {from_state} to {to_state}"
       self._metrics_writer.write_metric(
           timestamp=ts,
           wan_name=self.config.primary_wan,
           metric_name="wanctl_steering_enabled",
           value=1.0 if enable_steering else 0.0,
           labels={"reason": reason, "from_state": from_state, "to_state": to_state},
           granularity="raw",
       )
   ```

Avoid: Writing metrics when storage is disabled. Keep the write outside the critical routing path.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_steering*.py -v -k "not slow"` passes
Run: `.venv/bin/ruff check src/wanctl/steering/daemon.py` passes
Run: `.venv/bin/mypy src/wanctl/steering/daemon.py --no-error-summary` passes
  </verify>
  <done>
SteeringDaemon.run_cycle writes 5 metrics (rtt, baseline, delta, steering_enabled, state) each cycle when storage configured
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config snapshot module</name>
  <files>src/wanctl/storage/config_snapshot.py, src/wanctl/storage/__init__.py</files>
  <action>
Create a config snapshot recording module:

1. Create `src/wanctl/storage/config_snapshot.py`:
   ```python
   """
   Config Snapshot - Record configuration state on startup and reload.

   Stores a snapshot of relevant config values for debugging and audit.
   """

   import json
   import time
   from typing import Any

   from wanctl.storage.writer import MetricsWriter


   def record_config_snapshot(
       writer: MetricsWriter,
       wan_name: str,
       config_data: dict[str, Any],
       trigger: str = "startup",
   ) -> None:
       """Record a configuration snapshot to metrics storage.

       Extracts key configuration values and stores them as labeled metrics.
       Useful for tracking config changes and debugging historical behavior.

       Args:
           writer: MetricsWriter instance
           wan_name: WAN identifier
           config_data: Raw config dictionary
           trigger: What triggered the snapshot ("startup", "reload", "manual")
       """
       ts = int(time.time())

       # Extract key config values for autorate daemon
       autorate_config = {}
       if "continuous_monitoring" in config_data:
           cm = config_data["continuous_monitoring"]
           autorate_config = {
               "baseline_rtt_initial": cm.get("baseline_rtt_initial"),
               "download_ceiling_mbps": cm.get("download", {}).get("ceiling_mbps"),
               "upload_ceiling_mbps": cm.get("upload", {}).get("ceiling_mbps"),
               "target_bloat_ms": cm.get("thresholds", {}).get("target_bloat_ms"),
               "warn_bloat_ms": cm.get("thresholds", {}).get("warn_bloat_ms"),
           }

       # Extract key config values for steering daemon
       steering_config = {}
       if "thresholds" in config_data:
           thresh = config_data["thresholds"]
           steering_config = {
               "bad_threshold_ms": thresh.get("bad_threshold_ms"),
               "recovery_threshold_ms": thresh.get("recovery_threshold_ms"),
               "green_rtt_ms": thresh.get("green_rtt_ms"),
               "red_rtt_ms": thresh.get("red_rtt_ms"),
           }
       if "topology" in config_data:
           steering_config["primary_wan"] = config_data["topology"].get("primary_wan")
           steering_config["alternate_wan"] = config_data["topology"].get("alternate_wan")

       # Combine into snapshot
       snapshot = {
           "trigger": trigger,
           "autorate": autorate_config if autorate_config else None,
           "steering": steering_config if steering_config else None,
       }

       # Record as a labeled metric (value is timestamp for easy ordering)
       writer.write_metric(
           timestamp=ts,
           wan_name=wan_name,
           metric_name="wanctl_config_snapshot",
           value=float(ts),  # Timestamp as value for ordering
           labels=snapshot,
           granularity="raw",
       )
   ```

2. Update `src/wanctl/storage/__init__.py` to export the new function:
   Add to imports:
   ```python
   from wanctl.storage.config_snapshot import record_config_snapshot
   ```
   Add to `__all__`:
   ```python
   "record_config_snapshot",
   ```

3. Add config snapshot call to autorate main() in autorate_continuous.py, after controller creation:
   ```python
   # Record config snapshot on startup
   from wanctl.config_base import get_storage_config
   from wanctl.storage import MetricsWriter, record_config_snapshot
   first_config = controller.wan_controllers[0]["config"]
   storage_config = get_storage_config(first_config.data)
   if storage_config.get("db_path"):
       from pathlib import Path
       writer = MetricsWriter(Path(storage_config["db_path"]))
       record_config_snapshot(writer, first_config.wan_name, first_config.data, "startup")
   ```

4. Add config snapshot call to steering main() in daemon.py, after config load:
   ```python
   # Record config snapshot on startup
   storage_config = get_storage_config(config.data)
   if storage_config.get("db_path"):
       from pathlib import Path
       writer = MetricsWriter(Path(storage_config["db_path"]))
       from wanctl.storage import record_config_snapshot
       record_config_snapshot(writer, config.primary_wan, config.data, "startup")
   ```

Avoid: Storing sensitive config values (passwords, keys). Only store operational parameters relevant for debugging.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_storage*.py -v` passes
Run: `.venv/bin/ruff check src/wanctl/storage/` passes
Run: `.venv/bin/mypy src/wanctl/storage/config_snapshot.py --no-error-summary` passes
  </verify>
  <done>
Config snapshot module created, exports updated, both daemons record config on startup
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for steering metrics and config snapshots</name>
  <files>tests/test_steering_metrics_recording.py, tests/test_config_snapshot.py</files>
  <action>
Create comprehensive tests:

1. Create `tests/test_steering_metrics_recording.py`:
   ```python
   """Tests for steering daemon metrics recording integration."""

   import sqlite3
   import time
   from pathlib import Path

   import pytest

   from wanctl.storage import MetricsWriter


   class TestSteeringMetricsRecording:
       """Test metrics recording in steering run_cycle."""

       @pytest.fixture
       def temp_db(self, tmp_path):
           """Create temporary database for testing."""
           db_path = tmp_path / "test_steering_metrics.db"
           MetricsWriter._reset_instance()
           writer = MetricsWriter(db_path)
           yield db_path, writer
           MetricsWriter._reset_instance()

       def test_steering_metrics_written_each_cycle(self, temp_db):
           """Verify steering RTT and state metrics written to database."""
           db_path, writer = temp_db
           ts = int(time.time())

           # Simulate what steering run_cycle does
           metrics_batch = [
               (ts, "spectrum", "wanctl_rtt_ms", 28.5, None, "raw"),
               (ts, "spectrum", "wanctl_rtt_baseline_ms", 25.0, None, "raw"),
               (ts, "spectrum", "wanctl_rtt_delta_ms", 3.5, None, "raw"),
               (ts, "spectrum", "wanctl_steering_enabled", 0.0, None, "raw"),
               (ts, "spectrum", "wanctl_state", 0.0, {"source": "steering"}, "raw"),
           ]
           writer.write_metrics_batch(metrics_batch)

           # Verify
           conn = sqlite3.connect(db_path)
           rows = conn.execute("SELECT metric_name, value FROM metrics").fetchall()
           conn.close()

           assert len(rows) == 5
           metrics = {r[0]: r[1] for r in rows}
           assert metrics["wanctl_rtt_ms"] == 28.5
           assert metrics["wanctl_steering_enabled"] == 0.0

       def test_steering_transition_with_reason(self, temp_db):
           """Verify steering transitions include from/to state labels."""
           db_path, writer = temp_db
           ts = int(time.time())

           # Simulate state transition recording
           writer.write_metric(
               timestamp=ts,
               wan_name="spectrum",
               metric_name="wanctl_steering_enabled",
               value=1.0,
               labels={
                   "reason": "Transitioned from SPECTRUM_GOOD to SPECTRUM_DEGRADED",
                   "from_state": "SPECTRUM_GOOD",
                   "to_state": "SPECTRUM_DEGRADED",
               },
               granularity="raw",
           )

           # Verify labels stored
           conn = sqlite3.connect(db_path)
           row = conn.execute(
               "SELECT labels FROM metrics WHERE metric_name='wanctl_steering_enabled'"
           ).fetchone()
           conn.close()

           import json
           labels = json.loads(row[0])
           assert labels["from_state"] == "SPECTRUM_GOOD"
           assert labels["to_state"] == "SPECTRUM_DEGRADED"


   class TestSteeringPerformanceOverhead:
       """Verify steering metrics recording overhead is <5ms."""

       @pytest.fixture
       def temp_db(self, tmp_path):
           """Create temporary database for testing."""
           db_path = tmp_path / "perf_steering_metrics.db"
           MetricsWriter._reset_instance()
           writer = MetricsWriter(db_path)
           yield writer
           MetricsWriter._reset_instance()

       def test_steering_batch_write_under_5ms(self, temp_db):
           """Verify batch write completes in <5ms."""
           writer = temp_db
           ts = int(time.time())

           metrics_batch = [
               (ts, "spectrum", "wanctl_rtt_ms", 28.5, None, "raw"),
               (ts, "spectrum", "wanctl_rtt_baseline_ms", 25.0, None, "raw"),
               (ts, "spectrum", "wanctl_rtt_delta_ms", 3.5, None, "raw"),
               (ts, "spectrum", "wanctl_steering_enabled", 0.0, None, "raw"),
               (ts, "spectrum", "wanctl_state", 0.0, None, "raw"),
           ]

           # Measure write time
           start = time.monotonic()
           writer.write_metrics_batch(metrics_batch)
           elapsed_ms = (time.monotonic() - start) * 1000

           assert elapsed_ms < 5.0, f"Batch write took {elapsed_ms:.2f}ms, expected <5ms"
   ```

2. Create `tests/test_config_snapshot.py`:
   ```python
   """Tests for config snapshot recording."""

   import json
   import sqlite3
   import time
   from pathlib import Path

   import pytest

   from wanctl.storage import MetricsWriter
   from wanctl.storage.config_snapshot import record_config_snapshot


   class TestConfigSnapshot:
       """Test config snapshot recording."""

       @pytest.fixture
       def temp_db(self, tmp_path):
           """Create temporary database for testing."""
           db_path = tmp_path / "test_config_snapshot.db"
           MetricsWriter._reset_instance()
           writer = MetricsWriter(db_path)
           yield db_path, writer
           MetricsWriter._reset_instance()

       def test_autorate_config_snapshot(self, temp_db):
           """Verify autorate config values captured in snapshot."""
           db_path, writer = temp_db

           config_data = {
               "wan_name": "spectrum",
               "continuous_monitoring": {
                   "baseline_rtt_initial": 25.0,
                   "download": {"ceiling_mbps": 900},
                   "upload": {"ceiling_mbps": 40},
                   "thresholds": {
                       "target_bloat_ms": 15,
                       "warn_bloat_ms": 45,
                   },
               },
           }

           record_config_snapshot(writer, "spectrum", config_data, "startup")

           # Verify
           conn = sqlite3.connect(db_path)
           row = conn.execute(
               "SELECT labels FROM metrics WHERE metric_name='wanctl_config_snapshot'"
           ).fetchone()
           conn.close()

           labels = json.loads(row[0])
           assert labels["trigger"] == "startup"
           assert labels["autorate"]["baseline_rtt_initial"] == 25.0
           assert labels["autorate"]["download_ceiling_mbps"] == 900

       def test_steering_config_snapshot(self, temp_db):
           """Verify steering config values captured in snapshot."""
           db_path, writer = temp_db

           config_data = {
               "wan_name": "spectrum",
               "topology": {
                   "primary_wan": "spectrum",
                   "alternate_wan": "att",
               },
               "thresholds": {
                   "bad_threshold_ms": 25,
                   "recovery_threshold_ms": 12,
                   "green_rtt_ms": 5,
                   "red_rtt_ms": 15,
               },
           }

           record_config_snapshot(writer, "spectrum", config_data, "startup")

           # Verify
           conn = sqlite3.connect(db_path)
           row = conn.execute(
               "SELECT labels FROM metrics WHERE metric_name='wanctl_config_snapshot'"
           ).fetchone()
           conn.close()

           labels = json.loads(row[0])
           assert labels["trigger"] == "startup"
           assert labels["steering"]["primary_wan"] == "spectrum"
           assert labels["steering"]["bad_threshold_ms"] == 25

       def test_config_reload_trigger(self, temp_db):
           """Verify reload trigger captured correctly."""
           db_path, writer = temp_db

           record_config_snapshot(writer, "att", {}, "reload")

           # Verify
           conn = sqlite3.connect(db_path)
           row = conn.execute(
               "SELECT labels FROM metrics WHERE metric_name='wanctl_config_snapshot'"
           ).fetchone()
           conn.close()

           labels = json.loads(row[0])
           assert labels["trigger"] == "reload"
   ```

Run all tests to verify functionality.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_steering_metrics_recording.py -v` - all tests pass
Run: `.venv/bin/pytest tests/test_config_snapshot.py -v` - all tests pass
Run: `.venv/bin/pytest tests/test_steering*.py -v` - all steering tests still pass
Run: `.venv/bin/ruff check tests/test_steering_metrics_recording.py tests/test_config_snapshot.py` passes
  </verify>
  <done>
Tests prove: 5 steering metrics written per cycle, transitions include from/to states, config snapshots captured on startup, batch write <5ms
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Steering Metrics:** Run `.venv/bin/pytest tests/test_steering_metrics_recording.py -v` - all pass
2. **Config Snapshots:** Run `.venv/bin/pytest tests/test_config_snapshot.py -v` - all pass
3. **Existing Tests:** Run `.venv/bin/pytest tests/test_steering*.py -v` - no regressions
4. **Type Safety:** Run `.venv/bin/mypy src/wanctl/steering/daemon.py src/wanctl/storage/config_snapshot.py` - no errors
5. **Lint:** Run `.venv/bin/ruff check src/wanctl/` - clean
6. **Full Test Suite:** Run `.venv/bin/pytest tests/ -v --ignore=tests/integration` - all pass
</verification>

<success_criteria>
- DATA-01: RTT metrics recorded by steering daemon each cycle (verified by test_steering_metrics_written_each_cycle)
- DATA-04: Config snapshot saved on startup for both daemons (verified by test_autorate/steering_config_snapshot)
- INTG-02: Steering daemon records metrics each cycle (integration complete)
- INTG-03: Performance overhead <5ms (verified by test_steering_batch_write_under_5ms)
</success_criteria>

<output>
After completion, create `.planning/phases/39-data-recording/39-02-SUMMARY.md`
</output>
