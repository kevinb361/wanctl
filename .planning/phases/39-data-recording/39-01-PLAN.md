---
phase: 39-data-recording
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/autorate_continuous.py
  - tests/test_autorate_metrics_recording.py
autonomous: true

must_haves:
  truths:
    - "Autorate daemon records RTT metrics (current, baseline, delta) each cycle"
    - "Autorate daemon records rate metrics (download, upload) each cycle"
    - "Autorate daemon records state transitions with reason string"
    - "Recording overhead is <5ms per cycle"
  artifacts:
    - path: "src/wanctl/autorate_continuous.py"
      provides: "MetricsWriter integration in run_cycle"
      contains: "write_metrics_batch"
    - path: "tests/test_autorate_metrics_recording.py"
      provides: "Tests for metrics recording integration"
      min_lines: 100
  key_links:
    - from: "src/wanctl/autorate_continuous.py"
      to: "wanctl.storage.MetricsWriter"
      via: "import and batch write in run_cycle"
      pattern: "from wanctl\\.storage import MetricsWriter"
---

<objective>
Integrate MetricsWriter into the autorate daemon to record RTT and rate metrics each cycle.

Purpose: Enable historical analysis of congestion events by capturing per-cycle data with Prometheus-compatible naming. This is the foundation for the wanctl-history CLI tool and API endpoint.

Output: Modified autorate_continuous.py with metrics recording in run_cycle(), state transition recording with reason strings, and tests proving <5ms overhead.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-storage-foundation/38-02-SUMMARY.md
@src/wanctl/storage/__init__.py
@src/wanctl/storage/writer.py
@src/wanctl/storage/schema.py
@src/wanctl/autorate_continuous.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metrics recording to WANController.run_cycle</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Integrate MetricsWriter into the autorate daemon:

1. Add import at top:
   ```python
   from wanctl.storage import MetricsWriter
   from wanctl.config_base import get_storage_config
   ```

2. In WANController.__init__, add storage config:
   ```python
   # Metrics history storage (optional, disabled if db_path not configured)
   storage_config = get_storage_config(config.data)
   self._metrics_writer: MetricsWriter | None = None
   if storage_config.get("db_path"):
       from pathlib import Path
       self._metrics_writer = MetricsWriter(Path(storage_config["db_path"]))
   ```

3. In WANController.run_cycle, after the logging line (around line 1296), add metrics batch write:
   ```python
   # Record metrics to SQLite history (if enabled)
   if self._metrics_writer is not None:
       import time as time_module
       ts = int(time_module.time())
       metrics_batch = [
           (ts, self.wan_name, "wanctl_rtt_ms", measured_rtt, None, "raw"),
           (ts, self.wan_name, "wanctl_rtt_baseline_ms", self.baseline_rtt, None, "raw"),
           (ts, self.wan_name, "wanctl_rtt_delta_ms", delta, None, "raw"),
           (ts, self.wan_name, "wanctl_rate_download_mbps", dl_rate / 1e6, None, "raw"),
           (ts, self.wan_name, "wanctl_rate_upload_mbps", ul_rate / 1e6, None, "raw"),
       ]
       self._metrics_writer.write_metrics_batch(metrics_batch)
   ```

4. Add state encoding helper method to WANController:
   ```python
   def _encode_state(self, state: str) -> int:
       """Encode congestion state to numeric value for storage."""
       state_map = {"GREEN": 0, "YELLOW": 1, "SOFT_RED": 2, "RED": 3}
       return state_map.get(state, 0)
   ```

5. Add state to the metrics batch:
   ```python
   # Add download state (combined worst-of dl/ul for overall congestion)
   dl_state_val = self._encode_state(dl_zone)
   metrics_batch.append((ts, self.wan_name, "wanctl_state", float(dl_state_val), {"direction": "download"}, "raw"))
   ```

Avoid: Recording on every cycle when storage is disabled. Check for None writer before any write operation. Keep batch writes outside the rate limiter path to avoid impacting router API timing.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_autorate*.py -v -k "not slow"` passes
Run: `.venv/bin/ruff check src/wanctl/autorate_continuous.py` passes
Run: `.venv/bin/mypy src/wanctl/autorate_continuous.py --no-error-summary` passes
  </verify>
  <done>
WANController.run_cycle writes 6 metrics (rtt, baseline, delta, dl_rate, ul_rate, state) to MetricsWriter each cycle when storage is configured
  </done>
</task>

<task type="auto">
  <name>Task 2: Record state transitions with reason</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Add state transition recording to QueueController:

1. Modify QueueController.adjust_4state to return reason string along with zone and rate:
   - Add `_last_zone: str = "GREEN"` instance variable to track previous state
   - Build reason string based on delta values and thresholds when state changes
   - Return tuple: `(zone, new_rate, transition_reason)`

2. Update adjust_4state return signature to include optional reason:
   ```python
   def adjust_4state(
       self,
       baseline_rtt: float,
       load_rtt: float,
       green_threshold: float,
       soft_red_threshold: float,
       hard_red_threshold: float,
   ) -> tuple[str, int, str | None]:
       """
       Returns: (zone, new_rate, transition_reason)
       transition_reason is None if no state change, otherwise explains why
       """
   ```

3. At end of adjust_4state, before return:
   ```python
   # Track state transitions with reason
   transition_reason = None
   if zone != self._last_zone:
       delta = load_rtt - baseline_rtt
       if zone == "RED":
           transition_reason = f"RTT delta {delta:.1f}ms exceeded hard_red threshold {hard_red_threshold}ms"
       elif zone == "SOFT_RED":
           transition_reason = f"RTT delta {delta:.1f}ms exceeded soft_red threshold {soft_red_threshold}ms"
       elif zone == "YELLOW":
           transition_reason = f"RTT delta {delta:.1f}ms exceeded green threshold {green_threshold}ms"
       elif zone == "GREEN":
           transition_reason = f"RTT delta {delta:.1f}ms fell below green threshold {green_threshold}ms"
       self._last_zone = zone
   return zone, new_rate, transition_reason
   ```

4. Update QueueController.__init__ to initialize `self._last_zone = "GREEN"`

5. Update WANController.run_cycle to use the new return value and record transitions:
   ```python
   dl_zone, dl_rate, dl_transition_reason = self.download.adjust_4state(...)

   # Record state transition if occurred
   if dl_transition_reason and self._metrics_writer is not None:
       # Store transition as a labeled metric
       self._metrics_writer.write_metric(
           timestamp=ts,
           wan_name=self.wan_name,
           metric_name="wanctl_state",
           value=float(self._encode_state(dl_zone)),
           labels={"direction": "download", "reason": dl_transition_reason},
           granularity="raw",
       )
   ```

6. Similarly update adjust() for upload to return transition_reason (simpler 3-state version).

Avoid: Breaking the existing return signature in a way that causes cascade failures. Use a tuple that unpacks cleanly. Store transition reason in labels field for queryability.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_autorate*.py -v` passes (including existing tests)
Run: `.venv/bin/ruff check src/wanctl/autorate_continuous.py` passes
Run: `.venv/bin/mypy src/wanctl/autorate_continuous.py --no-error-summary` passes
  </verify>
  <done>
State transitions recorded with reason strings like "RTT delta 25.3ms exceeded soft_red threshold 45ms" in labels field
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and verify performance overhead</name>
  <files>tests/test_autorate_metrics_recording.py</files>
  <action>
Create comprehensive tests for metrics recording:

1. Create `tests/test_autorate_metrics_recording.py` with:

```python
"""Tests for autorate daemon metrics recording integration."""

import sqlite3
import time
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from wanctl.storage import MetricsWriter


class TestMetricsRecordingIntegration:
    """Test metrics recording in autorate run_cycle."""

    @pytest.fixture
    def temp_db(self, tmp_path):
        """Create temporary database for testing."""
        db_path = tmp_path / "test_metrics.db"
        MetricsWriter._reset_instance()
        writer = MetricsWriter(db_path)
        yield db_path, writer
        MetricsWriter._reset_instance()

    def test_metrics_written_each_cycle(self, temp_db):
        """Verify RTT and rate metrics written to database."""
        db_path, writer = temp_db
        ts = int(time.time())

        # Simulate what run_cycle does
        metrics_batch = [
            (ts, "spectrum", "wanctl_rtt_ms", 25.5, None, "raw"),
            (ts, "spectrum", "wanctl_rtt_baseline_ms", 22.0, None, "raw"),
            (ts, "spectrum", "wanctl_rtt_delta_ms", 3.5, None, "raw"),
            (ts, "spectrum", "wanctl_rate_download_mbps", 850.0, None, "raw"),
            (ts, "spectrum", "wanctl_rate_upload_mbps", 35.0, None, "raw"),
        ]
        writer.write_metrics_batch(metrics_batch)

        # Verify
        conn = sqlite3.connect(db_path)
        rows = conn.execute("SELECT metric_name, value FROM metrics").fetchall()
        conn.close()

        assert len(rows) == 5
        metrics = {r[0]: r[1] for r in rows}
        assert metrics["wanctl_rtt_ms"] == 25.5
        assert metrics["wanctl_rate_download_mbps"] == 850.0

    def test_state_transition_with_reason(self, temp_db):
        """Verify state transitions include reason labels."""
        db_path, writer = temp_db
        ts = int(time.time())

        # Simulate state transition recording
        writer.write_metric(
            timestamp=ts,
            wan_name="spectrum",
            metric_name="wanctl_state",
            value=2.0,  # SOFT_RED
            labels={"direction": "download", "reason": "RTT delta 50.3ms exceeded soft_red threshold 45ms"},
            granularity="raw",
        )

        # Verify labels stored
        conn = sqlite3.connect(db_path)
        row = conn.execute("SELECT labels FROM metrics WHERE metric_name='wanctl_state'").fetchone()
        conn.close()

        import json
        labels = json.loads(row[0])
        assert labels["reason"].startswith("RTT delta")
        assert "soft_red" in labels["reason"]


class TestPerformanceOverhead:
    """Verify metrics recording overhead is <5ms."""

    @pytest.fixture
    def temp_db(self, tmp_path):
        """Create temporary database for testing."""
        db_path = tmp_path / "perf_metrics.db"
        MetricsWriter._reset_instance()
        writer = MetricsWriter(db_path)
        yield writer
        MetricsWriter._reset_instance()

    def test_batch_write_under_5ms(self, temp_db):
        """Verify batch write completes in <5ms."""
        writer = temp_db
        ts = int(time.time())

        metrics_batch = [
            (ts, "spectrum", "wanctl_rtt_ms", 25.5, None, "raw"),
            (ts, "spectrum", "wanctl_rtt_baseline_ms", 22.0, None, "raw"),
            (ts, "spectrum", "wanctl_rtt_delta_ms", 3.5, None, "raw"),
            (ts, "spectrum", "wanctl_rate_download_mbps", 850.0, None, "raw"),
            (ts, "spectrum", "wanctl_rate_upload_mbps", 35.0, None, "raw"),
            (ts, "spectrum", "wanctl_state", 0.0, None, "raw"),
        ]

        # Measure write time
        start = time.monotonic()
        writer.write_metrics_batch(metrics_batch)
        elapsed_ms = (time.monotonic() - start) * 1000

        # Should complete in <5ms (typically <1ms)
        assert elapsed_ms < 5.0, f"Batch write took {elapsed_ms:.2f}ms, expected <5ms"

    def test_many_cycles_no_degradation(self, temp_db):
        """Verify performance doesn't degrade over many cycles."""
        writer = temp_db

        times = []
        for i in range(100):
            ts = int(time.time()) + i
            metrics_batch = [
                (ts, "spectrum", "wanctl_rtt_ms", 25.0 + i * 0.1, None, "raw"),
                (ts, "spectrum", "wanctl_rtt_baseline_ms", 22.0, None, "raw"),
                (ts, "spectrum", "wanctl_rtt_delta_ms", 3.0 + i * 0.1, None, "raw"),
                (ts, "spectrum", "wanctl_rate_download_mbps", 850.0, None, "raw"),
                (ts, "spectrum", "wanctl_rate_upload_mbps", 35.0, None, "raw"),
                (ts, "spectrum", "wanctl_state", 0.0, None, "raw"),
            ]
            start = time.monotonic()
            writer.write_metrics_batch(metrics_batch)
            times.append((time.monotonic() - start) * 1000)

        avg_time = sum(times) / len(times)
        max_time = max(times)

        # Average should be <2ms, max should be <5ms
        assert avg_time < 2.0, f"Average write time {avg_time:.2f}ms, expected <2ms"
        assert max_time < 5.0, f"Max write time {max_time:.2f}ms, expected <5ms"
```

2. Add tests for disabled storage (None writer):
```python
class TestDisabledStorage:
    """Test behavior when storage is disabled."""

    def test_no_error_when_storage_disabled(self):
        """Verify no error when MetricsWriter is None."""
        # Simulate disabled storage by not initializing writer
        writer = None

        # This pattern should not raise
        if writer is not None:
            writer.write_metrics_batch([])

        # No assertion needed - just verifying no exception
```

Run the tests to verify they pass and document the actual overhead.
  </action>
  <verify>
Run: `.venv/bin/pytest tests/test_autorate_metrics_recording.py -v` - all tests pass
Run: `.venv/bin/pytest tests/test_autorate*.py -v` - all existing autorate tests still pass
Run: `.venv/bin/ruff check tests/test_autorate_metrics_recording.py` passes
  </verify>
  <done>
Tests prove: 6 metrics written per cycle, state transitions include reason, batch write <5ms overhead, 100-cycle performance stable
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Metrics Recording:** Run `.venv/bin/pytest tests/test_autorate_metrics_recording.py -v` - all pass
2. **Existing Tests:** Run `.venv/bin/pytest tests/test_autorate*.py -v` - no regressions
3. **Type Safety:** Run `.venv/bin/mypy src/wanctl/autorate_continuous.py` - no errors
4. **Lint:** Run `.venv/bin/ruff check src/wanctl/` - clean
5. **Integration:** Storage module imports work, MetricsWriter singleton handles concurrent access
</verification>

<success_criteria>
- DATA-01: RTT metrics (current, baseline, delta) recorded each cycle (verified by test_metrics_written_each_cycle)
- DATA-02: Rate metrics (download, upload) recorded each cycle (verified by test_metrics_written_each_cycle)
- DATA-03: State transitions recorded with reason string (verified by test_state_transition_with_reason)
- INTG-01: Autorate daemon records metrics each cycle (integration complete)
- INTG-03: Performance overhead <5ms (verified by test_batch_write_under_5ms)
</success_criteria>

<output>
After completion, create `.planning/phases/39-data-recording/39-01-SUMMARY.md`
</output>
