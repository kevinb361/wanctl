---
phase: 06-quick-wins
plan: 06
type: execute
---

<objective>
Extract signal handler from calibrate.py for improved code organization, completing signal handler standardization across all entry points.

Purpose: Move nested signal_handler() to module-level for consistency with daemon pattern, even though calibrate.py is a one-shot utility.
Output: Module-level signal handling with register_signal_handlers() function.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@src/wanctl/steering/daemon.py (lines 95-144 - signal handling pattern)
@.planning/phases/06-quick-wins/06-01-SUMMARY.md
@.planning/phases/06-quick-wins/06-05-SUMMARY.md

**Established pattern (from steering/daemon.py and autorate_continuous.py Plans 1+5):**
- Module-level signal handling with threading.Event pattern
- Separate functions: _signal_handler(), register_signal_handlers(), is_shutdown_requested()

**Current calibrate.py structure:**
- Line 815-817: `def signal_handler(sig, frame):` (nested function)
- Line 819: `signal.signal(signal.SIGINT, signal_handler)`
- Behavior: Prints message and exits with code 130

**Key difference:** calibrate.py is a one-shot utility (not a daemon with control loop), so:
- No need for threading.Event or is_shutdown_requested()
- Signal handler can just print and exit immediately
- Simpler pattern than daemons

**Simplified pattern for one-shot utilities:**
```python
def _signal_handler(signum: int, frame) -> None:
    """Signal handler for SIGINT (Ctrl+C)"""
    print("\n\nCalibration interrupted.")
    sys.exit(130)

def register_signal_handlers() -> None:
    """Register SIGINT handler for graceful interruption"""
    signal.signal(signal.SIGINT, _signal_handler)
```

**Tech stack available:** Python 3.12, signal module, established pattern from Plans 1+5
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module-level signal handler for calibrate.py</name>
  <files>src/wanctl/calibrate.py</files>
  <action>Add module-level signal handling section after imports (around line 30, before Colors class):

1. Add section comment: "# =============================================================================" + "# SIGNAL HANDLING" + "# ============================================================================="
2. Create _signal_handler(signum: int, frame) -> None with docstring:
   ```python
   def _signal_handler(signum: int, frame) -> None:
       """
       Signal handler for SIGINT (Ctrl+C).

       Prints interruption message and exits with code 130 (standard for SIGINT).
       Used during calibration runs to allow graceful cancellation.

       Args:
           signum: Signal number received (should be SIGINT)
           frame: Current stack frame (unused)
       """
       print("\n\nCalibration interrupted.")
       sys.exit(130)
   ```
3. Create register_signal_handlers() -> None with docstring:
   ```python
   def register_signal_handlers() -> None:
       """
       Register signal handler for graceful interruption.

       Registers SIGINT (Ctrl+C) handler to allow user to cancel calibration.
       Does not handle SIGTERM as calibrate is interactive utility, not daemon.

       Should be called early in main() before long-running operations.
       """
       signal.signal(signal.SIGINT, _signal_handler)
   ```

Note: calibrate.py only needs SIGINT (Ctrl+C), not SIGTERM. It's an interactive utility, not a background daemon.

PRESERVE existing behavior exactly - just extract to module level for consistency.
  </action>
  <verify>grep -A 20 "SIGNAL HANDLING" src/wanctl/calibrate.py | grep -q "def register_signal_handlers"</verify>
  <done>Module-level signal handling functions exist for calibrate.py</done>
</task>

<task type="auto">
  <name>Task 2: Update main() to use extracted signal handler</name>
  <files>src/wanctl/calibrate.py</files>
  <action>Refactor main() function to use module-level signal handler:

1. REMOVE lines 815-819: nested signal_handler() function and signal.signal() call
2. ADD after argument parsing (around line 813, before "Run calibration" comment): `register_signal_handlers()`

This is much simpler than the daemon pattern since calibrate.py:
- Doesn't need threading.Event (no control loop to gracefully exit)
- Doesn't need is_shutdown_requested() checks (signal handler exits directly)
- Only handles SIGINT (interactive), not SIGTERM (daemon lifecycle)

PRESERVE exact existing behavior - just relocate signal setup.
  </action>
  <verify>grep "register_signal_handlers()" src/wanctl/calibrate.py && ! grep -A 5 "# Handle Ctrl+C gracefully" src/wanctl/calibrate.py | grep "def signal_handler"</verify>
  <done>main() uses module-level signal handler, nested function removed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Module-level signal handling section exists with 2 functions
- [ ] _signal_handler() has docstring explaining SIGINT handling
- [ ] register_signal_handlers() has docstring explaining one-shot utility pattern
- [ ] main() calls register_signal_handlers() after arg parsing
- [ ] Nested signal_handler removed from main()
- [ ] Behavior unchanged: Ctrl+C prints message and exits 130
- [ ] No syntax errors: python -m py_compile src/wanctl/calibrate.py
- [ ] Manual test: python -m wanctl.calibrate --help (should work)
</verification>

<success_criteria>

- All tasks completed
- Signal handling extracted to module level
- Pattern consistent with daemons (but simpler for one-shot utility)
- Behavior unchanged from original
- Code compiles without errors
- Phase 6 complete: All docstrings added, all signal handlers extracted
</success_criteria>

<output>
After completion, create `.planning/phases/06-quick-wins/06-06-SUMMARY.md`:

# Phase 6 Plan 6: Extract Signal Handlers - calibrate.py Summary

**Extracted signal handling from main() to module-level, completing Phase 6 Quick Wins**

## Accomplishments

- Created module-level signal handling (_signal_handler, register_signal_handlers)
- Removed nested signal_handler() function from main()
- Simplified pattern for one-shot utility (no threading.Event needed)
- **Phase 6 complete:** All docstrings added (9 items), all signal handlers extracted (2 files)

## Files Created/Modified

- `src/wanctl/calibrate.py` - Extracted signal handler, refactored main()

## Decisions Made

- **Simplified pattern:** calibrate.py uses simpler signal handling (no Event) since it's one-shot utility, not daemon
- **SIGINT only:** Only handles Ctrl+C, not SIGTERM (appropriate for interactive tool)

## Issues Encountered

None expected - extraction is straightforward

## Next Step

**Phase 6 Complete!** All quick wins delivered:
- ✓ Docstrings: autorate_continuous.py (2), steering/daemon.py (2), calibrate.py (3), state_manager.py (2)
- ✓ Signal handlers: autorate_continuous.py (extracted), calibrate.py (extracted), steering/daemon.py (already done)

Ready for Phase 7: Core Algorithm Analysis
</output>
