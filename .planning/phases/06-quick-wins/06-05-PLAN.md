---
phase: 06-quick-wins
plan: 05
type: execute
---

<objective>
Extract signal handler from autorate_continuous.py following steering/daemon.py pattern for improved code organization and reusability.

Purpose: Move nested handle_signal() to module-level using established pattern (threading.Event + register/check functions), improving consistency across daemons.
Output: Module-level signal handling with _shutdown_event, _signal_handler(), register_signal_handlers(), and is_shutdown_requested().
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@src/wanctl/steering/daemon.py (lines 95-144 - signal handling pattern)
@.planning/phases/06-quick-wins/06-01-SUMMARY.md
@.planning/phases/06-quick-wins/06-04-SUMMARY.md

**Established pattern (from steering/daemon.py):**
```python
# Module-level shutdown event
_shutdown_event = threading.Event()

def _signal_handler(signum: int, frame) -> None:
    """Signal handler - sets shutdown event"""
    _shutdown_event.set()

def register_signal_handlers() -> None:
    """Register SIGTERM and SIGINT handlers"""
    signal.signal(signal.SIGTERM, _signal_handler)
    signal.signal(signal.SIGINT, _signal_handler)

def is_shutdown_requested() -> bool:
    """Check if shutdown requested"""
    return _shutdown_event.is_set()
```

**Current autorate_continuous.py structure:**
- Line 1175: `shutdown_event = threading.Event()` (local variable)
- Line 1182-1186: `def handle_signal(signum, frame):` (nested function with logging)
- Line 1188-1189: `signal.signal()` calls
- Multiple checks: `shutdown_event.is_set()` throughout main loop

**Key difference:** autorate_continuous.py logs shutdown messages inside signal handler (iterating over controller.wan_controllers). This is unsafe - logging in signal handlers can deadlock.

**Solution:** Follow steering/daemon.py pattern - set event only in signal handler, log in main loop when event is set.

**Tech stack available:** Python 3.12, threading.Event, signal module, established pattern from steering/daemon.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module-level signal handling infrastructure</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>Add module-level signal handling section after imports (around line 54, before CONSTANTS section):

1. Add section comment: "# =============================================================================" + "# SIGNAL HANDLING" + "# ============================================================================="
2. Create _shutdown_event: `_shutdown_event = threading.Event()`
3. Create _signal_handler(signum: int, frame) -> None with docstring (copy from steering/daemon.py pattern, line 106-120)
4. Create register_signal_handlers() -> None with docstring (copy from steering/daemon.py pattern, line 123-134)
5. Create is_shutdown_requested() -> bool with docstring (copy from steering/daemon.py pattern, line 137-144)

All docstrings already exist in steering/daemon.py - replicate exactly for consistency. These functions should be identical between daemons.

IMPORTANT: Do NOT log in _signal_handler() - logging in signal handlers is unsafe. Comment should explain this.
  </action>
  <verify>grep -A 30 "SIGNAL HANDLING" src/wanctl/autorate_continuous.py | grep -q "def register_signal_handlers"</verify>
  <done>Module-level signal handling functions exist with threading.Event pattern</done>
</task>

<task type="auto">
  <name>Task 2: Update main() to use extracted signal handlers</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>Refactor main() function to use module-level signal handlers:

1. REMOVE line 1175: `shutdown_event = threading.Event()` (now module-level)
2. REMOVE lines 1182-1189: nested handle_signal() and signal.signal() calls
3. ADD after lockfile setup (around line 1173): `register_signal_handlers()`
4. REPLACE all `shutdown_event.is_set()` with `is_shutdown_requested()` (multiple locations in main loop)
5. REPLACE all `shutdown_event.set()` with direct shutdown (should only be in main loop on error)
6. ADD logging AFTER detecting shutdown (in main loop):
   ```python
   if is_shutdown_requested():
       for wan_info in controller.wan_controllers:
           wan_info['logger'].info("Shutdown requested, exiting gracefully...")
       break
   ```

This moves logging OUT of signal handler (unsafe) into main loop (safe). The shutdown message should appear when the event is detected, not when the signal fires.

PRESERVE all existing shutdown logic - just relocate signal setup and logging.
  </action>
  <verify>grep -c "is_shutdown_requested()" src/wanctl/autorate_continuous.py | grep -v "^0$"</verify>
  <done>main() uses module-level signal handlers, logging moved to main loop, all shutdown_event references replaced</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Module-level signal handling section exists with 4 components
- [ ] All docstrings present and match steering/daemon.py pattern
- [ ] main() calls register_signal_handlers() early
- [ ] No logging in _signal_handler() (unsafe)
- [ ] Shutdown logging happens in main loop (safe)
- [ ] All shutdown_event references replaced with module-level functions
- [ ] No syntax errors: python -m py_compile src/wanctl/autorate_continuous.py
- [ ] Run tests: pytest tests/ (integration test if available)
</verification>

<success_criteria>

- All tasks completed
- Signal handling matches steering/daemon.py pattern exactly
- No logging in signal handler (deadlock prevention)
- Shutdown detection works correctly in main loop
- Code compiles without errors
- Consistent signal handling pattern across all daemons
</success_criteria>

<output>
After completion, create `.planning/phases/06-quick-wins/06-05-SUMMARY.md`:

# Phase 6 Plan 5: Extract Signal Handlers - autorate_continuous.py Summary

**Extracted signal handling from main() to module-level following steering/daemon.py pattern**

## Accomplishments

- Created module-level signal handling infrastructure (_shutdown_event, _signal_handler, register/check functions)
- Removed nested handle_signal() function from main()
- Moved shutdown logging from signal handler (unsafe) to main loop (safe)
- Established consistent signal handling pattern across all daemons

## Files Created/Modified

- `src/wanctl/autorate_continuous.py` - Extracted signal handlers, refactored main()

## Decisions Made

- **Logging safety:** Moved all logging out of signal handler into main loop (prevents potential deadlocks)
- **Pattern consistency:** Used identical structure to steering/daemon.py for maintainability

## Issues Encountered

None expected - pattern already proven in steering/daemon.py

## Next Step

Ready for 06-06-PLAN.md (extract signal handlers: calibrate.py)

**Progress:** 5/6 plans complete. One signal handler extraction remaining.
</output>
