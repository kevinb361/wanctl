---
phase: 23-edge-case-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_rate_limiter.py
  - tests/test_wan_controller.py
autonomous: true

must_haves:
  truths:
    - "Test proves burst limit enforced within single RateLimiter session"
    - "Test documents restart behavior (new instance = fresh quota)"
    - "Test proves dual fallback failure returns (False, None), not stale load_rtt"
    - "Test verifies stale data protection across all fallback modes"
  artifacts:
    - path: "tests/test_rate_limiter.py"
      provides: "TestRapidRestartBehavior class"
      contains: "class TestRapidRestartBehavior"
    - path: "tests/test_wan_controller.py"
      provides: "TestDualFallbackFailure class"
      contains: "class TestDualFallbackFailure"
  key_links:
    - from: "tests/test_rate_limiter.py"
      to: "src/wanctl/rate_utils.py"
      via: "RateLimiter import"
      pattern: "from wanctl.rate_utils import RateLimiter"
    - from: "tests/test_wan_controller.py"
      to: "src/wanctl/autorate_continuous.py"
      via: "WANController import"
      pattern: "from wanctl.autorate_continuous import WANController"
---

<objective>
Add edge case tests for rate limiter rapid restart behavior and dual fallback failure scenarios.

Purpose: Close TEST-04 and TEST-05 requirements from v1.3 scope. Proves boundary conditions are explicitly tested.
Output: New test classes in existing test files, all tests passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-edge-case-tests/23-RESEARCH.md

# Existing test patterns
@tests/test_rate_limiter.py
@tests/test_wan_controller.py

# Implementation under test
@src/wanctl/rate_utils.py
@src/wanctl/autorate_continuous.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RateLimiter rapid restart tests (TEST-04)</name>
  <files>tests/test_rate_limiter.py</files>
  <action>
Add new test class `TestRapidRestartBehavior` at end of file with these tests:

1. `test_burst_limit_enforced_within_session` - Production defaults (10 changes/60s), verify 10 changes allowed then 11th blocked, check `changes_remaining() == 0` at limit.

2. `test_window_expiration_allows_new_changes` - Use mocked `time.monotonic` (existing pattern in TestMonotonicTime). Record 10 changes at time T, verify blocked, advance time to T+61, verify `can_change() == True`.

3. `test_new_instance_has_fresh_quota` - Create limiter, exhaust quota (10 changes), verify blocked. Create NEW limiter instance, verify `can_change() == True` and `changes_remaining() == 10`. Document in docstring that restart creates fresh quota (design characteristic).

4. `test_rapid_sequential_changes_at_production_defaults` - Verify production behavior: 10 changes/60s. Rapid-fire 10 changes, confirm all succeed, confirm 11th blocked. Similar to existing `test_concurrent_like_behavior` but with production defaults.

Follow existing test patterns exactly (pytest, unittest.mock, no real time.sleep for mocked tests).
  </action>
  <verify>`.venv/bin/pytest tests/test_rate_limiter.py -v` passes with new tests visible</verify>
  <done>4 new tests in TestRapidRestartBehavior class, all passing, TEST-04 satisfied</done>
</task>

<task type="auto">
  <name>Task 2: Add dual fallback failure tests (TEST-05)</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Add new test class `TestDualFallbackFailure` after TestHandleIcmpFailure class. Reuse existing fixtures (mock_config, mock_router, mock_rtt_measurement, mock_logger, controller).

Tests to add:

1. `test_dual_failure_returns_safe_defaults_not_stale_data` - Set `controller.load_rtt = 28.5` (stale value). Mock `verify_connectivity_fallback` to return `(False, None)`. Call `handle_icmp_failure()`. Assert `should_continue is False` AND `measured_rtt is None` (NOT 28.5). Docstring: "Proves stale load_rtt is NOT returned when both ICMP and TCP fail."

2. `test_dual_failure_safe_across_all_fallback_modes` - Parameterize over ["graceful_degradation", "freeze", "use_last_rtt"]. For each mode: set load_rtt to distinct stale value, mock dual failure, verify `(False, None)` returned regardless of mode.

3. `test_dual_failure_does_not_increment_cycle_counter` - Verify `icmp_unavailable_cycles` stays at 0 when dual failure occurs. Total connectivity loss should not increment the ICMP unavailable counter.

4. `test_dual_failure_logs_warning` - Verify warning logged on total connectivity loss. Check `controller.logger.warning.assert_called()`.

Follow existing test patterns (pytest fixtures, MagicMock, patch.object). Place class after TestHandleIcmpFailure to maintain logical grouping.
  </action>
  <verify>`.venv/bin/pytest tests/test_wan_controller.py::TestDualFallbackFailure -v` passes</verify>
  <done>4 new tests in TestDualFallbackFailure class, all passing, TEST-05 satisfied</done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
.venv/bin/pytest tests/test_rate_limiter.py tests/test_wan_controller.py -v
```

Verify test count increased:
```bash
.venv/bin/pytest tests/ --collect-only | grep "test session starts" -A1
```
</verification>

<success_criteria>
- [ ] TestRapidRestartBehavior class exists with 4 tests
- [ ] TestDualFallbackFailure class exists with 4 tests
- [ ] All new tests pass
- [ ] No regressions in existing tests
- [ ] TEST-04 requirement satisfied (rate limiter burst protection proven)
- [ ] TEST-05 requirement satisfied (safe defaults on dual failure proven)
</success_criteria>

<output>
After completion, create `.planning/phases/23-edge-case-tests/23-01-SUMMARY.md`
</output>
