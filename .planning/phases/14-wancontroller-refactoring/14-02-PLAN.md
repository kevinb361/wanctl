---
phase: 14-wancontroller-refactoring
plan: 02
type: execute
risk: LOW
---

<objective>
Extract flash wear protection and rate limiting logic from run_cycle() into a dedicated method.

Purpose: Reduce run_cycle() complexity by another 45 lines and isolate hardware protection logic.
Output: New apply_rate_changes_if_needed() method protecting RouterOS NAND flash.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/CORE-ALGORITHM-ANALYSIS.md
@src/wanctl/autorate_continuous.py
@.planning/phases/14-wancontroller-refactoring/14-01-SUMMARY.md

**Phase 7 Recommendation (W2):**
- Location: Lines 895-940 (45 lines within run_cycle())
- Proposed: `apply_rate_changes_if_needed(dl_rate, ul_rate) -> bool`
- Benefits: Separates flash wear protection from cycle logic
- Risk: LOW - clear boundaries, no algorithm changes

**Protected Zones:**
- Flash wear protection logic - MUST PRESERVE, just move to method
- Rate limiting logic - MUST PRESERVE, just move to method
- DO NOT change thresholds or detection logic

**Depends on:** Plan 14-01 (run_cycle() already simplified)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apply_rate_changes_if_needed() method</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Extract flash wear protection + rate limiting (lines ~895-940 after Plan 01) into new method:

```python
def apply_rate_changes_if_needed(self, dl_rate: int, ul_rate: int) -> bool:
    """
    Apply rate changes to router with flash wear protection and rate limiting.

    Only sends updates to router when rates have actually changed (flash wear
    protection) and within the rate limit window (API overload protection).

    PROTECTED LOGIC - RouterOS writes queue changes to NAND flash. Repeated
    writes accelerate flash wear. See docs/CORE-ALGORITHM-ANALYSIS.md.

    Args:
        dl_rate: Download rate in bits per second
        ul_rate: Upload rate in bits per second

    Returns:
        True if cycle should continue (rates applied or skipped),
        False if router update failed (triggers watchdog restart)

    Side Effects:
        - Updates last_applied_dl_rate/last_applied_ul_rate on success
        - Records rate_limiter change on successful router update
        - Records metrics (router_update, rate_limit_event)
        - Calls save_state() when rate limited
    """
```

The method should:
1. Check if rates changed (flash wear protection):
   ```python
   if dl_rate == self.last_applied_dl_rate and ul_rate == self.last_applied_ul_rate:
       self.logger.debug(f"{self.wan_name}: Rates unchanged, skipping router update (flash wear protection)")
       return True  # Success - no update needed
   ```

2. Check rate limiter:
   ```python
   if not self.rate_limiter.can_change():
       wait_time = self.rate_limiter.time_until_available()
       self.logger.warning(...)
       if self.config.metrics_enabled:
           record_rate_limit_event(self.wan_name)
       self.save_state()  # Preserve state when throttled
       return True  # Success - throttled but not failure
   ```

3. Apply to router:
   ```python
   success = self.router.set_limits(wan=self.wan_name, down_bps=dl_rate, up_bps=ul_rate)
   if not success:
       self.logger.error(f"{self.wan_name}: Failed to apply limits")
       return False
   ```

4. Record success:
   ```python
   self.rate_limiter.record_change()
   if self.config.metrics_enabled:
       record_router_update(self.wan_name)
   self.last_applied_dl_rate = dl_rate
   self.last_applied_ul_rate = ul_rate
   self.logger.debug(f"{self.wan_name}: Applied new limits to router")
   return True
   ```

Update run_cycle() to use the new method:
```python
# Apply rate changes (with flash wear + rate limit protection)
if not self.apply_rate_changes_if_needed(dl_rate, ul_rate):
    return False

# Save state after successful cycle
self.save_state()
```

PRESERVE all existing behavior:
- Change detection logic (dl_rate != last_applied_dl_rate or ul_rate != ...)
- Rate limiting behavior (can_change(), record_change(), time_until_available())
- Metrics recording (record_router_update, record_rate_limit_event)
- Logging at same levels
- Return values (True for success/throttle, False for router failure)
  </action>
  <verify>make test && python -c "from wanctl.autorate_continuous import WANController; print('Import OK')"</verify>
  <done>apply_rate_changes_if_needed() method exists, run_cycle() uses it, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for flash wear and rate limiting</name>
  <files>tests/test_autorate_continuous.py</files>
  <action>
Add unit tests for apply_rate_changes_if_needed():

1. **Flash wear protection:**
   - Same rates as last_applied → no router call, returns True
   - Different DL rate → router called
   - Different UL rate → router called

2. **Rate limiting:**
   - Within limit → router called
   - Exceeded limit → throttled, save_state called, returns True
   - Records rate_limit_event metric when throttled

3. **Router failure:**
   - router.set_limits() returns False → returns False

4. **State tracking:**
   - Updates last_applied_* on success
   - Records change with rate_limiter on success
   - Records router_update metric on success

Test structure:
```python
class TestApplyRateChangesIfNeeded:
    """Tests for WANController.apply_rate_changes_if_needed() method."""

    def test_unchanged_rates_skip_router_call(self, ...):
        """Flash wear protection: unchanged rates should not call router."""
        controller.last_applied_dl_rate = 100_000_000
        controller.last_applied_ul_rate = 20_000_000
        result = controller.apply_rate_changes_if_needed(100_000_000, 20_000_000)
        assert result is True
        assert router_mock.set_limits.call_count == 0

    def test_changed_dl_rate_calls_router(self, ...):
        """Changed download rate should call router."""

    def test_rate_limited_skips_router_saves_state(self, ...):
        """Rate limit exceeded should skip router but save state."""
        rate_limiter_mock.can_change.return_value = False
        result = controller.apply_rate_changes_if_needed(...)
        assert result is True
        assert state_mock.save_state.called

    def test_router_failure_returns_false(self, ...):
        """Router.set_limits failure should return False."""
        router_mock.set_limits.return_value = False
        result = controller.apply_rate_changes_if_needed(...)
        assert result is False

    def test_success_updates_tracking(self, ...):
        """Successful update should track last_applied rates and record change."""
```

Mock router.set_limits(), rate_limiter.can_change(), config.metrics_enabled.
  </action>
  <verify>make test && pytest tests/test_autorate_continuous.py -v -k "apply_rate" --tb=short</verify>
  <done>New tests cover flash wear and rate limiting, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (format, lint, type, test)
- [ ] apply_rate_changes_if_needed() method exists with proper docstring
- [ ] Flash wear protection logic preserved exactly
- [ ] Rate limiting logic preserved exactly
- [ ] run_cycle() now ~55 lines (after Plan 01 + 02)
</verification>

<success_criteria>
- apply_rate_changes_if_needed() extracted with clear contract
- run_cycle() reduced by additional ~45 lines
- All 474+ tests pass
- New tests cover flash wear and rate limiting paths
- No behavioral changes (refactoring only)
</success_criteria>

<output>
After completion, create `.planning/phases/14-wancontroller-refactoring/14-02-SUMMARY.md`
</output>
