---
phase: 14-wancontroller-refactoring
plan: 03
type: execute
risk: LOW
---

<objective>
Extract concurrent RTT measurement logic to RTTMeasurement utility class.

Purpose: Move ThreadPoolExecutor complexity to shared utility, simplify WANController.measure_rtt().
Output: New ping_hosts_concurrent() method in RTTMeasurement, reusable by steering daemon.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/CORE-ALGORITHM-ANALYSIS.md
@src/wanctl/rtt_measurement.py
@src/wanctl/autorate_continuous.py
@.planning/phases/14-wancontroller-refactoring/14-02-SUMMARY.md

**Phase 7 Recommendation (W3):**
- Location: WANController.measure_rtt() lines 649-678 (30 lines)
- Proposed: Move concurrent futures logic to rtt_measurement.py
- Benefits: Reduces measure_rtt() from 42 to ~15 lines, reusable utility
- Risk: LOW - no algorithm changes, moves complexity to utility

**Depends on:** Plans 14-01 and 14-02 (run_cycle() simplified)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ping_hosts_concurrent() to RTTMeasurement</name>
  <files>src/wanctl/rtt_measurement.py</files>
  <action>
Add new method to RTTMeasurement class:

```python
def ping_hosts_concurrent(
    self,
    hosts: list[str],
    count: int = 1,
    timeout: float = 3.0
) -> list[float]:
    """
    Ping multiple hosts concurrently and return successful RTTs.

    Uses ThreadPoolExecutor to ping all hosts in parallel, reducing total
    measurement time for median-of-three scenarios from 3x to 1x.

    Args:
        hosts: List of hostnames/IPs to ping
        count: Number of ping packets per host (passed to ping_host)
        timeout: Total timeout for all concurrent pings in seconds

    Returns:
        List of successful RTT measurements in milliseconds.
        Empty list if all pings failed.

    Example:
        >>> rtt = RTTMeasurement(logger)
        >>> rtts = rtt.ping_hosts_concurrent(["8.8.8.8", "1.1.1.1", "9.9.9.9"])
        >>> rtts
        [12.3, 10.5, 14.2]
        >>> statistics.median(rtts)
        12.3
    """
    import concurrent.futures

    if not hosts:
        return []

    rtts: list[float] = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(hosts)) as executor:
        # Submit all pings in parallel
        future_to_host = {
            executor.submit(self.ping_host, host, count): host
            for host in hosts
        }

        # Collect results with timeout
        for future in concurrent.futures.as_completed(future_to_host, timeout=timeout):
            host = future_to_host[future]
            try:
                rtt = future.result()
                if rtt is not None:
                    rtts.append(rtt)
            except Exception as e:
                self.logger.debug(f"Concurrent ping to {host} failed: {e}")

    return rtts
```

Add the import at top of file:
```python
import concurrent.futures
```

Note: The method uses ping_host() internally, so aggregation strategy from __init__ applies.
  </action>
  <verify>make test && python -c "from wanctl.rtt_measurement import RTTMeasurement; print('Import OK')"</verify>
  <done>ping_hosts_concurrent() method exists in RTTMeasurement class</done>
</task>

<task type="auto">
  <name>Task 2: Refactor WANController.measure_rtt() to use utility</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Simplify measure_rtt() to use the new utility:

```python
def measure_rtt(self) -> float | None:
    """
    Measure RTT and return value in milliseconds.

    For connections with reflector variation (cable): Uses median-of-three reflectors
    For stable connections (DSL, fiber): Single reflector is sufficient

    Uses concurrent pings for faster cycle times when median-of-three is enabled.
    """
    if self.use_median_of_three and len(self.ping_hosts) >= 3:
        # Ping multiple hosts concurrently, take median to handle reflector variation
        hosts_to_ping = self.ping_hosts[:3]
        rtts = self.rtt_measurement.ping_hosts_concurrent(
            hosts=hosts_to_ping,
            count=1,
            timeout=3.0
        )

        if len(rtts) >= 2:
            median_rtt = statistics.median(rtts)
            self.logger.debug(f"{self.wan_name}: Median-of-{len(rtts)} RTT = {median_rtt:.2f}ms")
            return median_rtt
        elif len(rtts) == 1:
            return rtts[0]
        else:
            self.logger.warning(f"{self.wan_name}: All pings failed (median-of-three)")
            return None
    else:
        # Single host ping
        return self.rtt_measurement.ping_host(self.ping_hosts[0], count=1)
```

Remove the inline ThreadPoolExecutor import and usage.
Keep statistics import at file level (already present).

The method is now ~20 lines instead of ~42 lines:
- Aggregation logic (median/single) stays in WANController
- Concurrent execution complexity moves to utility
  </action>
  <verify>make test && python -c "from wanctl.autorate_continuous import WANController; print('Import OK')"</verify>
  <done>measure_rtt() simplified, uses ping_hosts_concurrent(), all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for concurrent ping utility</name>
  <files>tests/test_rtt_measurement.py</files>
  <action>
Add unit tests for ping_hosts_concurrent():

```python
class TestPingHostsConcurrent:
    """Tests for RTTMeasurement.ping_hosts_concurrent() method."""

    def test_returns_list_of_rtts(self, rtt_measurement, mock_subprocess):
        """Should return list of successful RTT values."""
        mock_subprocess.return_value.returncode = 0
        mock_subprocess.return_value.stdout = "time=12.3 ms"

        rtts = rtt_measurement.ping_hosts_concurrent(["8.8.8.8", "1.1.1.1"])

        assert len(rtts) == 2
        assert all(isinstance(rtt, float) for rtt in rtts)

    def test_empty_hosts_returns_empty_list(self, rtt_measurement):
        """Should return empty list for empty hosts."""
        assert rtt_measurement.ping_hosts_concurrent([]) == []

    def test_partial_failures_return_successful_only(self, rtt_measurement, mock_subprocess):
        """Should return only successful pings when some fail."""
        # First ping succeeds, second fails
        mock_subprocess.side_effect = [
            Mock(returncode=0, stdout="time=12.3 ms"),
            Mock(returncode=1, stdout=""),
        ]

        rtts = rtt_measurement.ping_hosts_concurrent(["8.8.8.8", "1.1.1.1"])

        assert len(rtts) == 1
        assert rtts[0] == pytest.approx(12.3)

    def test_all_failures_return_empty_list(self, rtt_measurement, mock_subprocess):
        """Should return empty list when all pings fail."""
        mock_subprocess.return_value.returncode = 1

        rtts = rtt_measurement.ping_hosts_concurrent(["8.8.8.8", "1.1.1.1"])

        assert rtts == []

    def test_timeout_handled_gracefully(self, rtt_measurement, mock_subprocess):
        """Should handle timeout without crashing."""
        mock_subprocess.side_effect = subprocess.TimeoutExpired(cmd="ping", timeout=3)

        rtts = rtt_measurement.ping_hosts_concurrent(["8.8.8.8"], timeout=0.1)

        assert rtts == []
```

Test concurrent behavior by mocking subprocess.run().
Verify partial failures, total failures, and timeout handling.
  </action>
  <verify>make test && pytest tests/test_rtt_measurement.py -v -k "concurrent" --tb=short</verify>
  <done>New tests cover concurrent ping utility, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (format, lint, type, test)
- [ ] ping_hosts_concurrent() exists in RTTMeasurement
- [ ] WANController.measure_rtt() uses new utility
- [ ] measure_rtt() reduced from ~42 to ~20 lines
- [ ] New tests cover concurrent ping edge cases
</verification>

<success_criteria>
- Concurrent RTT logic moved to reusable utility
- WANController.measure_rtt() simplified by ~50%
- All 474+ tests pass
- New utility is available for steering daemon (Phase 15)
- No behavioral changes (refactoring only)
</success_criteria>

<output>
After completion, create `.planning/phases/14-wancontroller-refactoring/14-03-SUMMARY.md`
</output>
