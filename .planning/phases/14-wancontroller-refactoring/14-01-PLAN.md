---
phase: 14-wancontroller-refactoring
plan: 01
type: execute
risk: LOW
---

<objective>
Extract fallback connectivity logic from run_cycle() into a dedicated method.

Purpose: Reduce run_cycle() complexity by 32% (68 lines) and isolate fallback logic for independent testing.
Output: New handle_icmp_failure() method with clear input/output contract.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/CORE-ALGORITHM-ANALYSIS.md
@src/wanctl/autorate_continuous.py

**Phase 7 Recommendation (W1):**
- Location: Lines 794-861 (68 lines within run_cycle())
- Proposed: `handle_icmp_failure() -> tuple[bool, float | None]`
- Benefits: Isolates fallback logic, enables testing of 3 modes independently
- Risk: LOW - pure extraction, no algorithm changes

**Protected Zones (do not modify):**
- Baseline update threshold (lines 688-698) - EWMA logic
- Flash wear protection (lines 895-940) - handled in Plan 02
- Rate limiting logic (lines 903-915) - handled in Plan 02
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handle_icmp_failure() method</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Extract lines 794-861 from run_cycle() into a new method:

```python
def handle_icmp_failure(self) -> tuple[bool, float | None]:
    """
    Handle ICMP ping failure with fallback connectivity checks.

    Called when measure_rtt() returns None. Runs fallback connectivity checks
    (gateway ping, TCP handshake) and applies mode-specific behavior:
    - graceful_degradation: Use last RTT (cycle 1), freeze (cycles 2-3), fail (cycle 4+)
    - freeze: Always freeze rates, return success
    - use_last_rtt: Always use last known RTT

    Returns:
        (should_continue, measured_rtt):
        - should_continue: True if cycle should proceed (or end successfully), False to trigger restart
        - measured_rtt: RTT value to use (from last known), or None if should_continue is False

    Note:
        Also handles ICMP recovery (resetting icmp_unavailable_cycles when ICMP returns).
    """
```

The method should:
1. Record metrics if ICMP failed (record_ping_failure)
2. Run verify_connectivity_fallback()
3. If has_connectivity:
   - Increment icmp_unavailable_cycles
   - Apply fallback_mode logic (graceful_degradation, freeze, use_last_rtt)
   - Return (True, measured_rtt) or (True, None) for freeze modes
4. If no connectivity:
   - Return (False, None) for total loss
5. Handle ICMP recovery case (reset counter when called with successful ICMP)

Update run_cycle() to:
```python
def run_cycle(self) -> bool:
    measured_rtt = self.measure_rtt()

    if measured_rtt is None:
        should_continue, measured_rtt = self.handle_icmp_failure()
        if not should_continue:
            return False
        if measured_rtt is None:
            # Freeze mode - save state and return success
            self.save_state()
            return True
    else:
        # ICMP succeeded - reset fallback counter if needed
        if self.icmp_unavailable_cycles > 0:
            self.logger.info(f"{self.wan_name}: ICMP recovered after {self.icmp_unavailable_cycles} cycles")
            self.icmp_unavailable_cycles = 0

    # Continue with normal processing...
```

Preserve ALL existing behavior:
- Metrics recording (record_ping_failure)
- Logging at same levels (warning, error, info)
- Return values (True for success/freeze, False for failures)
- Counter tracking (icmp_unavailable_cycles)
  </action>
  <verify>make test && python -c "from wanctl.autorate_continuous import WANController; print('Import OK')"</verify>
  <done>handle_icmp_failure() method exists, run_cycle() uses it, all 474 tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for fallback modes</name>
  <files>tests/test_autorate_continuous.py</files>
  <action>
Add unit tests for handle_icmp_failure() covering all 3 fallback modes:

1. **graceful_degradation mode:**
   - Cycle 1: Returns (True, last_rtt)
   - Cycle 2-3: Returns (True, None) - freeze
   - Cycle 4+: Returns (False, None) - fail

2. **freeze mode:**
   - Always returns (True, None)

3. **use_last_rtt mode:**
   - Always returns (True, last_rtt)

4. **Total connectivity loss:**
   - verify_connectivity_fallback() returns False
   - Returns (False, None)

5. **ICMP recovery:**
   - When measured_rtt is valid after icmp_unavailable_cycles > 0
   - Counter resets, logs info message

Test structure:
```python
class TestHandleIcmpFailure:
    """Tests for WANController.handle_icmp_failure() method."""

    @pytest.fixture
    def controller_with_mode(self, mode):
        """Create controller with specific fallback_mode."""
        # Setup with mocked dependencies

    def test_graceful_degradation_cycle_1_uses_last_rtt(self, ...):
        """Cycle 1 should use last known RTT."""

    def test_graceful_degradation_cycle_2_3_freezes(self, ...):
        """Cycles 2-3 should freeze rates."""

    def test_graceful_degradation_cycle_4_plus_fails(self, ...):
        """Cycle 4+ should trigger failure."""

    def test_freeze_mode_always_freezes(self, ...):
        """Freeze mode should always return success with None RTT."""

    def test_use_last_rtt_mode_uses_last(self, ...):
        """use_last_rtt mode should always return last RTT."""

    def test_total_connectivity_loss_returns_false(self, ...):
        """Should return False when no connectivity at all."""

    def test_icmp_recovery_resets_counter(self, ...):
        """Should reset icmp_unavailable_cycles when ICMP recovers."""
```

Mock verify_connectivity_fallback() to control has_connectivity.
Mock config.fallback_mode and config.fallback_max_cycles.
Verify correct return values and counter behavior.
  </action>
  <verify>make test && pytest tests/test_autorate_continuous.py -v -k "handle_icmp" --tb=short</verify>
  <done>New tests cover all fallback modes, all tests pass including new ones</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (format, lint, type, test)
- [ ] handle_icmp_failure() method exists with proper docstring
- [ ] run_cycle() is shorter by ~68 lines
- [ ] All 3 fallback modes tested independently
- [ ] No changes to protected zones (EWMA, flash wear, rate limiting)
</verification>

<success_criteria>
- handle_icmp_failure() extracted with clear contract
- run_cycle() reduced from ~170 lines to ~100 lines
- All 474+ tests pass
- New tests cover all fallback mode paths
- No behavioral changes (refactoring only)
</success_criteria>

<output>
After completion, create `.planning/phases/14-wancontroller-refactoring/14-01-SUMMARY.md`
</output>
