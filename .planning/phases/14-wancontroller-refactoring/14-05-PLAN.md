---
phase: 14-wancontroller-refactoring
plan: 05
type: execute
risk: MEDIUM
approved: true
---

<objective>
Extract state persistence to dedicated WANControllerState manager class.

Purpose: Separate persistence from business logic, enable reuse, improve testability.
Output: New WANControllerState class following StateManager pattern from steering daemon.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/CORE-ALGORITHM-ANALYSIS.md
@src/wanctl/autorate_continuous.py
@src/wanctl/state_utils.py
@.planning/phases/14-wancontroller-refactoring/14-04-SUMMARY.md

**Phase 7 Recommendation (W5):**
- Location: load_state() + save_state() (72 lines total)
- Proposed: Create WANControllerState class following steering's StateManager pattern
- Benefits: Separates persistence from business logic, enables testing without file I/O
- Risk: MEDIUM - changes initialization flow, schema must remain compatible

**USER APPROVED:** This MEDIUM risk item was explicitly approved for Phase 14.

**State Schema (MUST PRESERVE):**
```json
{
  "download": { "green_streak": 0, "soft_red_streak": 0, "red_streak": 0, "current_rate": N },
  "upload": { "green_streak": 0, "soft_red_streak": 0, "red_streak": 0, "current_rate": N },
  "ewma": { "baseline_rtt": N, "load_rtt": N },
  "last_applied": { "dl_rate": N, "ul_rate": N },
  "timestamp": "ISO-8601"
}
```

**Existing Utilities:**
- state_utils.py: safe_json_load_file(), atomic_write_json()
- steering/state_manager.py: StateManager pattern (reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WANControllerState class</name>
  <files>src/wanctl/wan_controller_state.py</files>
  <action>
Create new module for WANController state persistence:

```python
"""
WANController state persistence manager.

Handles loading and saving WANController state (hysteresis counters, EWMA values,
last applied rates) with atomic writes and error recovery. Follows the StateManager
pattern from steering/state_manager.py.
"""

import datetime
import logging
from pathlib import Path
from typing import Any

from .state_utils import atomic_write_json, safe_json_load_file


class WANControllerState:
    """
    Manages state persistence for WANController.

    Separates persistence concerns from business logic, enabling:
    - Isolated testing of state save/load without WANController
    - Consistent atomic write behavior
    - Clear schema documentation

    State Schema:
        {
            "download": {"green_streak", "soft_red_streak", "red_streak", "current_rate"},
            "upload": {"green_streak", "soft_red_streak", "red_streak", "current_rate"},
            "ewma": {"baseline_rtt", "load_rtt"},
            "last_applied": {"dl_rate", "ul_rate"},
            "timestamp": ISO-8601 string
        }
    """

    def __init__(self, state_file: Path, logger: logging.Logger, wan_name: str):
        """
        Initialize state manager.

        Args:
            state_file: Path to state JSON file
            logger: Logger for error/debug messages
            wan_name: WAN name for log context
        """
        self.state_file = state_file
        self.logger = logger
        self.wan_name = wan_name

    def load(self) -> dict[str, Any] | None:
        """
        Load state from disk.

        Returns:
            State dictionary if found and valid, None if missing or invalid.
            Caller should use defaults when None returned.
        """
        state = safe_json_load_file(
            self.state_file,
            logger=self.logger,
            default=None,
            error_context=f"{self.wan_name} state"
        )

        if state is not None:
            self.logger.debug(f"{self.wan_name}: Loaded state from {self.state_file}")

        return state

    def save(
        self,
        download: dict[str, Any],
        upload: dict[str, Any],
        ewma: dict[str, float],
        last_applied: dict[str, int | None]
    ) -> None:
        """
        Save state to disk with atomic write.

        Args:
            download: Download controller state (streaks, current_rate)
            upload: Upload controller state (streaks, current_rate)
            ewma: EWMA state (baseline_rtt, load_rtt)
            last_applied: Last applied rates (dl_rate, ul_rate)
        """
        state = {
            'download': download,
            'upload': upload,
            'ewma': ewma,
            'last_applied': last_applied,
            'timestamp': datetime.datetime.now().isoformat()
        }

        atomic_write_json(self.state_file, state)
        self.logger.debug(f"{self.wan_name}: Saved state to {self.state_file}")

    def build_download_state(
        self,
        green_streak: int,
        soft_red_streak: int,
        red_streak: int,
        current_rate: int
    ) -> dict[str, int]:
        """Build download state dict for save()."""
        return {
            'green_streak': green_streak,
            'soft_red_streak': soft_red_streak,
            'red_streak': red_streak,
            'current_rate': current_rate
        }

    def build_upload_state(
        self,
        green_streak: int,
        soft_red_streak: int,
        red_streak: int,
        current_rate: int
    ) -> dict[str, int]:
        """Build upload state dict for save()."""
        return {
            'green_streak': green_streak,
            'soft_red_streak': soft_red_streak,
            'red_streak': red_streak,
            'current_rate': current_rate
        }
```

The class:
1. Uses existing utilities (safe_json_load_file, atomic_write_json)
2. Follows steering's StateManager pattern
3. Preserves exact schema structure
4. Provides helper methods for building state dicts
  </action>
  <verify>python -c "from wanctl.wan_controller_state import WANControllerState; print('Import OK')"</verify>
  <done>WANControllerState class created with load/save methods</done>
</task>

<task type="auto">
  <name>Task 2: Refactor WANController to use state manager</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Update WANController to use WANControllerState:

1. Add import:
```python
from .wan_controller_state import WANControllerState
```

2. Update __init__() to create state manager:
```python
# In __init__(), before load_state() call:
self.state_manager = WANControllerState(
    state_file=config.state_file,
    logger=logger,
    wan_name=wan_name
)
```

3. Simplify load_state():
```python
@handle_errors(error_msg="{self.wan_name}: Could not load state: {exception}")
def load_state(self) -> None:
    """Load persisted hysteresis state from disk."""
    state = self.state_manager.load()

    if state is not None:
        # Restore download controller state
        if 'download' in state:
            dl = state['download']
            self.download.green_streak = dl.get('green_streak', 0)
            self.download.soft_red_streak = dl.get('soft_red_streak', 0)
            self.download.red_streak = dl.get('red_streak', 0)
            self.download.current_rate = dl.get('current_rate', self.download.ceiling_bps)

        # Restore upload controller state
        if 'upload' in state:
            ul = state['upload']
            self.upload.green_streak = ul.get('green_streak', 0)
            self.upload.soft_red_streak = ul.get('soft_red_streak', 0)
            self.upload.red_streak = ul.get('red_streak', 0)
            self.upload.current_rate = ul.get('current_rate', self.upload.ceiling_bps)

        # Restore EWMA state
        if 'ewma' in state:
            ewma = state['ewma']
            self.baseline_rtt = ewma.get('baseline_rtt', self.baseline_rtt)
            self.load_rtt = ewma.get('load_rtt', self.load_rtt)

        # Restore last applied rates (flash wear protection)
        if 'last_applied' in state:
            applied = state['last_applied']
            self.last_applied_dl_rate = applied.get('dl_rate')
            self.last_applied_ul_rate = applied.get('ul_rate')
```

4. Simplify save_state():
```python
@handle_errors(error_msg="{self.wan_name}: Could not save state: {exception}")
def save_state(self) -> None:
    """Save hysteresis state to disk for persistence across restarts."""
    self.state_manager.save(
        download=self.state_manager.build_download_state(
            self.download.green_streak,
            self.download.soft_red_streak,
            self.download.red_streak,
            self.download.current_rate
        ),
        upload=self.state_manager.build_upload_state(
            self.upload.green_streak,
            self.upload.soft_red_streak,
            self.upload.red_streak,
            self.upload.current_rate
        ),
        ewma={
            'baseline_rtt': self.baseline_rtt,
            'load_rtt': self.load_rtt
        },
        last_applied={
            'dl_rate': self.last_applied_dl_rate,
            'ul_rate': self.last_applied_ul_rate
        }
    )
```

PRESERVE:
- Exact state schema (keys, types, structure)
- Error handling decorators
- Default value behavior on missing keys
- All existing functionality
  </action>
  <verify>make test && python -c "from wanctl.autorate_continuous import WANController; print('Import OK')"</verify>
  <done>WANController uses WANControllerState, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add state manager tests</name>
  <files>tests/test_wan_controller_state.py</files>
  <action>
Create new test file for WANControllerState:

```python
"""Tests for WANControllerState persistence manager."""

import json
import tempfile
from pathlib import Path
from unittest.mock import MagicMock

import pytest

from wanctl.wan_controller_state import WANControllerState


class TestWANControllerState:
    """Tests for WANControllerState class."""

    @pytest.fixture
    def state_file(self, tmp_path):
        """Temporary state file path."""
        return tmp_path / "test-state.json"

    @pytest.fixture
    def state_manager(self, state_file):
        """State manager instance."""
        logger = MagicMock()
        return WANControllerState(state_file, logger, "test-wan")

    def test_load_returns_none_for_missing_file(self, state_manager):
        """Should return None when state file doesn't exist."""
        assert state_manager.load() is None

    def test_load_returns_state_dict(self, state_manager, state_file):
        """Should return state dict when file exists."""
        state = {
            "download": {"green_streak": 5},
            "upload": {"green_streak": 3},
            "ewma": {"baseline_rtt": 20.0},
            "last_applied": {"dl_rate": 100000000}
        }
        state_file.write_text(json.dumps(state))

        result = state_manager.load()

        assert result == state

    def test_save_creates_file(self, state_manager, state_file):
        """Should create state file on save."""
        state_manager.save(
            download={"green_streak": 5, "soft_red_streak": 0, "red_streak": 0, "current_rate": 100000000},
            upload={"green_streak": 3, "soft_red_streak": 0, "red_streak": 0, "current_rate": 20000000},
            ewma={"baseline_rtt": 20.0, "load_rtt": 22.0},
            last_applied={"dl_rate": 100000000, "ul_rate": 20000000}
        )

        assert state_file.exists()
        state = json.loads(state_file.read_text())
        assert "download" in state
        assert "upload" in state
        assert "ewma" in state
        assert "last_applied" in state
        assert "timestamp" in state

    def test_save_preserves_schema(self, state_manager, state_file):
        """Saved state should match expected schema exactly."""
        state_manager.save(
            download={"green_streak": 5, "soft_red_streak": 1, "red_streak": 0, "current_rate": 100000000},
            upload={"green_streak": 3, "soft_red_streak": 0, "red_streak": 2, "current_rate": 20000000},
            ewma={"baseline_rtt": 20.5, "load_rtt": 22.3},
            last_applied={"dl_rate": 100000000, "ul_rate": 20000000}
        )

        state = json.loads(state_file.read_text())

        # Verify schema structure
        assert state["download"]["green_streak"] == 5
        assert state["download"]["soft_red_streak"] == 1
        assert state["upload"]["red_streak"] == 2
        assert state["ewma"]["baseline_rtt"] == 20.5
        assert state["last_applied"]["dl_rate"] == 100000000

    def test_build_download_state(self, state_manager):
        """Should build correct download state dict."""
        result = state_manager.build_download_state(5, 1, 0, 100000000)

        assert result == {
            "green_streak": 5,
            "soft_red_streak": 1,
            "red_streak": 0,
            "current_rate": 100000000
        }

    def test_load_invalid_json_returns_none(self, state_manager, state_file):
        """Should return None for invalid JSON."""
        state_file.write_text("not valid json {{{")

        assert state_manager.load() is None

    def test_roundtrip_preserves_data(self, state_manager, state_file):
        """Save then load should preserve all data."""
        original = {
            "download": {"green_streak": 5, "soft_red_streak": 1, "red_streak": 0, "current_rate": 100000000},
            "upload": {"green_streak": 3, "soft_red_streak": 0, "red_streak": 2, "current_rate": 20000000},
            "ewma": {"baseline_rtt": 20.5, "load_rtt": 22.3},
            "last_applied": {"dl_rate": 100000000, "ul_rate": 20000000}
        }

        state_manager.save(**original)
        loaded = state_manager.load()

        # Compare without timestamp
        for key in ["download", "upload", "ewma", "last_applied"]:
            assert loaded[key] == original[key]
```
  </action>
  <verify>make test && pytest tests/test_wan_controller_state.py -v --tb=short</verify>
  <done>State manager tests pass, schema preservation verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (format, lint, type, test)
- [ ] WANControllerState class exists in new module
- [ ] WANController uses state manager for load/save
- [ ] State schema UNCHANGED (roundtrip test verifies)
- [ ] Existing state files remain compatible
- [ ] All 474+ tests pass
</verification>

<success_criteria>
- WANControllerState extracted following StateManager pattern
- State persistence separated from business logic
- Schema exactly preserved (backward compatible)
- All tests pass including new state manager tests
- Phase 14 complete: 60%+ reduction in run_cycle() complexity
</success_criteria>

<output>
After completion, create `.planning/phases/14-wancontroller-refactoring/14-05-SUMMARY.md`:

Include Phase 14 Summary section with:
- Total lines reduced in run_cycle()
- Methods extracted (handle_icmp_failure, apply_rate_changes_if_needed, ping_hosts_concurrent, _update_baseline_if_idle)
- New modules created (wan_controller_state.py)
- Test coverage added
- Protected zones preserved
</output>
