---
phase: 14-wancontroller-refactoring
plan: 04
type: execute
risk: MEDIUM
approved: true
---

<objective>
Extract EWMA baseline update validation logic into a dedicated helper method.

Purpose: Make baseline update conditional logic more explicit and add debug logging.
Output: New _update_baseline_if_idle() helper with clear protected zone marking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/CORE-ALGORITHM-ANALYSIS.md
@src/wanctl/autorate_continuous.py
@.planning/phases/14-wancontroller-refactoring/14-03-SUMMARY.md

**Phase 7 Recommendation (W4):**
- Location: update_ewma() lines 683-698 (16 lines)
- Proposed: Extract baseline conditional to _update_baseline_if_idle() helper
- Benefits: Makes protected logic more explicit, adds debug logging
- Risk: MEDIUM - touches core algorithm (baseline update threshold)

**USER APPROVED:** This MEDIUM risk item was explicitly approved for Phase 14.

**PROTECTED ZONE - Baseline Update Threshold:**
The conditional baseline update is an ARCHITECTURAL INVARIANT:
- Baseline ONLY updates when delta < threshold (line is idle)
- Prevents baseline drift under load (would mask true bloat)
- Threshold value (3ms default) is production-tuned
- DO NOT change the formula or remove the conditional
- Adding logging and extracting to helper is SAFE
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _update_baseline_if_idle() helper method</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
Extract baseline update logic from update_ewma() into dedicated helper:

```python
def update_ewma(self, measured_rtt: float) -> None:
    """
    Update both EWMAs (fast load, slow baseline).

    Fast EWMA (load_rtt): Responsive to current conditions, always updates.
    Slow EWMA (baseline_rtt): Only updates when line is idle (delta < threshold).
    """
    # Fast EWMA for load_rtt (responsive to current conditions)
    self.load_rtt = (1 - self.alpha_load) * self.load_rtt + self.alpha_load * measured_rtt

    # Slow EWMA for baseline_rtt (conditional update via protected logic)
    self._update_baseline_if_idle(measured_rtt)

def _update_baseline_if_idle(self, measured_rtt: float) -> None:
    """
    Update baseline RTT ONLY when line is idle (delta < threshold).

    PROTECTED ZONE - ARCHITECTURAL INVARIANT
    =========================================
    This logic prevents baseline drift under load. If baseline tracked load RTT,
    delta would approach zero and bloat detection would fail. The threshold
    (baseline_update_threshold) determines "idle" vs "under load".

    DO NOT MODIFY without explicit approval. See docs/CORE-ALGORITHM-ANALYSIS.md.

    Args:
        measured_rtt: Current RTT measurement in milliseconds

    Side Effects:
        Updates self.baseline_rtt if delta < threshold (line is idle).
        Logs debug message when baseline updates (helps debug drift issues).
    """
    delta = self.load_rtt - self.baseline_rtt

    # PROTECTED: Baseline ONLY updates when line is idle
    if delta < self.baseline_update_threshold:
        # Line is idle or nearly idle - safe to update baseline
        old_baseline = self.baseline_rtt
        self.baseline_rtt = (1 - self.alpha_baseline) * self.baseline_rtt + self.alpha_baseline * measured_rtt
        self.logger.debug(
            f"{self.wan_name}: Baseline updated {old_baseline:.2f}ms -> {self.baseline_rtt:.2f}ms "
            f"(delta={delta:.1f}ms < threshold={self.baseline_update_threshold}ms)"
        )
    # else: Under load - freeze baseline (no update, no logging to avoid spam)
```

Key points:
1. PRESERVE the exact conditional logic: `delta < self.baseline_update_threshold`
2. PRESERVE the EWMA formula: `(1 - alpha) * current + alpha * new`
3. ADD debug logging ONLY when baseline updates (not on freeze)
4. ADD prominent PROTECTED ZONE comment
5. ADD docstring explaining the invariant

Remove the inline logic from update_ewma() - it now just calls the helper.
  </action>
  <verify>make test && python -c "from wanctl.autorate_continuous import WANController; print('Import OK')"</verify>
  <done>_update_baseline_if_idle() method exists with protected zone comments, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add validation tests for baseline drift protection</name>
  <files>tests/test_autorate_continuous.py</files>
  <action>
Add unit tests that validate the baseline drift protection invariant:

```python
class TestUpdateBaselineIfIdle:
    """Tests for WANController._update_baseline_if_idle() baseline protection."""

    def test_baseline_updates_when_idle(self, controller):
        """Baseline should update when delta < threshold (idle)."""
        controller.baseline_rtt = 20.0
        controller.load_rtt = 21.0  # delta = 1ms
        controller.baseline_update_threshold = 3.0

        controller._update_baseline_if_idle(22.0)

        # Baseline should have moved toward measured_rtt
        assert controller.baseline_rtt > 20.0

    def test_baseline_freezes_under_load(self, controller):
        """Baseline should NOT update when delta >= threshold (under load)."""
        controller.baseline_rtt = 20.0
        controller.load_rtt = 25.0  # delta = 5ms
        controller.baseline_update_threshold = 3.0

        original_baseline = controller.baseline_rtt
        controller._update_baseline_if_idle(30.0)

        # Baseline should NOT change
        assert controller.baseline_rtt == original_baseline

    def test_baseline_freeze_prevents_drift(self, controller):
        """Simulated load scenario: baseline must not drift toward load."""
        controller.baseline_rtt = 20.0
        controller.load_rtt = 20.0
        controller.baseline_update_threshold = 3.0
        controller.alpha_baseline = 0.1  # 10% weight

        # Simulate 100 cycles under load
        for _ in range(100):
            # Load increases
            controller.load_rtt = 50.0  # High load RTT
            measured_rtt = 55.0  # Even higher measurement

            # Update EWMA (full method to test integration)
            controller.update_ewma(measured_rtt)

        # Baseline should NOT have drifted significantly toward load
        # With delta > threshold, baseline freezes at original value
        assert controller.baseline_rtt == pytest.approx(20.0, abs=0.1)

    def test_threshold_boundary_exact_equal(self, controller):
        """Edge case: delta exactly equals threshold."""
        controller.baseline_rtt = 20.0
        controller.load_rtt = 23.0  # delta = 3ms exactly
        controller.baseline_update_threshold = 3.0

        original_baseline = controller.baseline_rtt
        controller._update_baseline_if_idle(25.0)

        # delta >= threshold should freeze (not update)
        assert controller.baseline_rtt == original_baseline

    def test_baseline_logs_on_update(self, controller, caplog):
        """Should log debug message when baseline updates."""
        controller.baseline_rtt = 20.0
        controller.load_rtt = 20.5  # delta = 0.5ms (idle)
        controller.baseline_update_threshold = 3.0

        with caplog.at_level(logging.DEBUG):
            controller._update_baseline_if_idle(21.0)

        assert "Baseline updated" in caplog.text
```

These tests validate:
1. Normal operation (idle → updates)
2. Protected behavior (under load → freezes)
3. Drift prevention over many cycles
4. Boundary condition (delta == threshold)
5. Debug logging presence
  </action>
  <verify>make test && pytest tests/test_autorate_continuous.py -v -k "baseline" --tb=short</verify>
  <done>New tests validate baseline drift protection invariant, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (format, lint, type, test)
- [ ] _update_baseline_if_idle() method exists with PROTECTED ZONE comments
- [ ] Baseline conditional logic UNCHANGED (delta < threshold)
- [ ] EWMA formula UNCHANGED ((1-alpha)*current + alpha*new)
- [ ] Debug logging added (only on update, not freeze)
- [ ] Tests validate drift prevention invariant
</verification>

<success_criteria>
- _update_baseline_if_idle() extracted with prominent protected zone marking
- Baseline update logic EXACTLY preserved (pure refactoring)
- Debug logging added without changing behavior
- Validation tests prove drift protection works
- All 474+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-wancontroller-refactoring/14-04-SUMMARY.md`
</output>
