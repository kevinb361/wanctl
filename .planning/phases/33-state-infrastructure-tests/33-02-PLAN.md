---
phase: 33-state-infrastructure-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_error_handling.py
  - tests/test_signal_utils.py
  - tests/test_systemd_utils.py
  - tests/test_path_utils.py
autonomous: true

must_haves:
  truths:
    - "error_handling.py coverage >= 90%"
    - "signal_utils.py coverage >= 90%"
    - "systemd_utils.py coverage >= 90%"
    - "path_utils.py coverage >= 90%"
    - "All notify functions tested with both available and unavailable systemd"
  artifacts:
    - path: "tests/test_error_handling.py"
      provides: "Error handling decorator and context manager tests"
      min_lines: 150
    - path: "tests/test_signal_utils.py"
      provides: "Signal handler and shutdown event tests"
      min_lines: 80
    - path: "tests/test_systemd_utils.py"
      provides: "Systemd notification function tests"
      min_lines: 80
    - path: "tests/test_path_utils.py"
      provides: "Expanded path utility tests"
      min_lines: 250
  key_links:
    - from: "tests/test_error_handling.py"
      to: "src/wanctl/error_handling.py"
      via: "imports handle_errors, safe_operation, safe_call"
      pattern: "from wanctl.error_handling import"
    - from: "tests/test_signal_utils.py"
      to: "src/wanctl/signal_utils.py"
      via: "imports signal functions and _shutdown_event"
      pattern: "from wanctl.signal_utils import"
---

<objective>
Add comprehensive test coverage for infrastructure utility modules.

Purpose: Cover error handling, signals, systemd, and path utilities to 90%+.
Output: New test files for error_handling.py, signal_utils.py, systemd_utils.py; expanded test_path_utils.py.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-state-infrastructure-tests/33-RESEARCH.md
@src/wanctl/error_handling.py
@src/wanctl/signal_utils.py
@src/wanctl/systemd_utils.py
@src/wanctl/path_utils.py
@tests/test_path_utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error_handling.py tests</name>
  <files>tests/test_error_handling.py</files>
  <action>
Create new test file `tests/test_error_handling.py` covering:

**TestHandleErrorsDecorator:**

1. Basic behavior:
   - Returns function result on success
   - Returns default_return on exception
   - Logs at specified log_level (use caplog)

2. Logger discovery:
   - Finds logger from self.logger attribute
   - Falls back to module logger when no self.logger
   - Test object without logger attribute

3. Error message formatting:
   - Custom error_msg used when provided
   - {exception} placeholder replaced
   - {self.attr} placeholder replaced from first arg
   - Format failure falls back to default message

4. Advanced parameters:
   - log_traceback=True: logs traceback at DEBUG level
   - callable default_return: invoked on exception
   - exception_types filtering: catches specified, lets others through
   - reraise=True: re-raises after logging
   - on_error callback: invoked with exception, callback errors caught

Pattern for test objects (from RESEARCH.md):
```python
class MockObject:
    def __init__(self, logger):
        self.logger = logger
        self.attr = "test_value"

    @handle_errors(default_return=None)
    def method_that_fails(self):
        raise ValueError("test error")
```

**TestSafeOperationContextManager:**

1. Yields successfully on no exception
2. Catches exception, logs at specified level
3. log_traceback logs at DEBUG
4. exception_types filtering works

**TestSafeCallFunction:**

1. Returns function result on success
2. Returns default on exception
3. Uses module logger when none provided
4. log_traceback logs at DEBUG
5. Logs function name in error message
  </action>
  <verify>pytest tests/test_error_handling.py -v --tb=short && pytest tests/test_error_handling.py --cov=wanctl.error_handling --cov-report=term-missing</verify>
  <done>error_handling.py at 90%+ coverage with all decorator paths tested</done>
</task>

<task type="auto">
  <name>Task 2: Create signal_utils.py tests</name>
  <files>tests/test_signal_utils.py</files>
  <action>
Create new test file `tests/test_signal_utils.py` covering:

**TestSignalUtils:**

Use `reset_shutdown_state()` in setup to isolate tests (Pitfall 4 from RESEARCH.md).

1. `is_shutdown_requested`:
   - Returns False when event not set
   - Returns True after event set

2. `_signal_handler`:
   - Sets the shutdown event
   - Works for both SIGTERM (15) and SIGINT (2)

3. `register_signal_handlers`:
   - With include_sigterm=True: registers both SIGTERM and SIGINT
   - With include_sigterm=False: registers only SIGINT
   - Use mock to verify signal.signal calls

4. `get_shutdown_event`:
   - Returns the module-level Event
   - Returned event is same object as _shutdown_event

5. `wait_for_shutdown`:
   - With timeout=None and event set: returns True immediately
   - With timeout and event not set: returns False after timeout
   - Verify blocking behavior with timeout

6. `reset_shutdown_state`:
   - Clears the event
   - is_shutdown_requested returns False after reset

Pattern (from RESEARCH.md):
```python
from wanctl.signal_utils import (
    is_shutdown_requested,
    reset_shutdown_state,
    _signal_handler,
    register_signal_handlers,
    get_shutdown_event,
    wait_for_shutdown,
)

class TestSignalUtils:
    def setup_method(self):
        reset_shutdown_state()

    def teardown_method(self):
        reset_shutdown_state()
```
  </action>
  <verify>pytest tests/test_signal_utils.py -v --tb=short && pytest tests/test_signal_utils.py --cov=wanctl.signal_utils --cov-report=term-missing</verify>
  <done>signal_utils.py at 90%+ coverage with all signal handler paths tested</done>
</task>

<task type="auto">
  <name>Task 3: Create systemd_utils.py tests and expand path_utils.py tests</name>
  <files>tests/test_systemd_utils.py, tests/test_path_utils.py</files>
  <action>
**Create tests/test_systemd_utils.py:**

Patch both `_HAVE_SYSTEMD` and `_sd_notify` together (Pitfall 5 from RESEARCH.md).

**TestSystemdUtils:**

1. `is_systemd_available`:
   - Returns True when _HAVE_SYSTEMD is True
   - Returns False when _HAVE_SYSTEMD is False

2. `notify_ready`:
   - With systemd available: calls _sd_notify("READY=1")
   - With _sd_notify=None: no-op (no exception)

3. `notify_watchdog`:
   - With systemd available: calls _sd_notify("WATCHDOG=1")
   - Without systemd: no-op

4. `notify_status`:
   - With systemd available: calls _sd_notify("STATUS={message}")
   - Without systemd: no-op

5. `notify_stopping`:
   - With systemd available: calls _sd_notify("STOPPING=1")
   - Without systemd: no-op

6. `notify_degraded`:
   - With systemd available: calls _sd_notify("STATUS=Degraded - {message}")
   - Without systemd: no-op

Pattern (from RESEARCH.md):
```python
def test_notify_watchdog_calls_sd_notify(self):
    with patch("wanctl.systemd_utils._sd_notify") as mock_notify:
        with patch("wanctl.systemd_utils._HAVE_SYSTEMD", True):
            notify_watchdog()
    mock_notify.assert_called_once_with("WATCHDOG=1")
```

**Expand tests/test_path_utils.py:**

1. `get_cake_root`:
   - With CAKE_ROOT env set: returns that path
   - Without CAKE_ROOT: returns parents[2] of module file
   - Use monkeypatch.setenv for env var tests

2. `ensure_directory_exists` error handling:
   - Mock Path.mkdir to raise OSError
   - Verify exception propagates
   - Verify error logged

3. `ensure_file_directory` with resolve=True:
   - Create symlink to a file
   - Call with resolve=True
   - Verify resolves symlink before creating parent

4. `safe_file_path` without explicit logger:
   - Don't pass logger parameter
   - Verify function works (uses module logger internally)
  </action>
  <verify>pytest tests/test_systemd_utils.py tests/test_path_utils.py -v --tb=short && pytest tests/test_systemd_utils.py tests/test_path_utils.py --cov=wanctl.systemd_utils --cov=wanctl.path_utils --cov-report=term-missing</verify>
  <done>systemd_utils.py and path_utils.py both at 90%+ coverage</done>
</task>

</tasks>

<verification>
Run coverage check for all infrastructure modules:
```bash
pytest tests/test_error_handling.py tests/test_signal_utils.py tests/test_systemd_utils.py tests/test_path_utils.py \
  --cov=wanctl.error_handling --cov=wanctl.signal_utils --cov=wanctl.systemd_utils --cov=wanctl.path_utils \
  --cov-report=term-missing --cov-fail-under=90
```

Expected: Each module >= 90% coverage
</verification>

<success_criteria>
- error_handling.py coverage >= 90%
- signal_utils.py coverage >= 90%
- systemd_utils.py coverage >= 90%
- path_utils.py coverage >= 90%
- All notify functions tested with both systemd available and unavailable
- Signal handler state properly isolated between tests
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-state-infrastructure-tests/33-02-SUMMARY.md`
</output>
