---
phase: 44-fail-safe-behavior
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/pending_rates.py
  - src/wanctl/autorate_continuous.py
  - tests/test_pending_rates.py
  - tests/test_autorate_continuous.py
autonomous: true

must_haves:
  truths:
    - "Rate changes are queued when router is unreachable"
    - "Queued rate is applied when router becomes reachable"
    - "Stale rates (>60s) are discarded on reconnection"
    - "Daemon remains healthy during router outages"
  artifacts:
    - path: "src/wanctl/pending_rates.py"
      provides: "PendingRateChange class for tracking pending rates"
      exports: ["PendingRateChange"]
    - path: "tests/test_pending_rates.py"
      provides: "Unit tests for PendingRateChange"
      min_lines: 50
  key_links:
    - from: "src/wanctl/autorate_continuous.py"
      to: "src/wanctl/pending_rates.py"
      via: "import and instantiation in WANController.__init__"
      pattern: "from wanctl.pending_rates import PendingRateChange"
    - from: "src/wanctl/autorate_continuous.py"
      to: "self.pending_rates.queue"
      via: "call in apply_rate_changes_if_needed when router unreachable"
      pattern: "self.pending_rates.queue"
---

<objective>
Implement fail-closed rate limit persistence for router outages.

Purpose: Ensure rate limits are never lost during router communication failures. When router is unreachable, queue calculated rates for later application instead of discarding them. This implements requirement ERRR-03: Rate limits are never removed on error.

Output: PendingRateChange class, integration with apply_rate_changes_if_needed(), and comprehensive tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-fail-safe-behavior/44-CONTEXT.md
@.planning/phases/44-fail-safe-behavior/44-RESEARCH.md
@src/wanctl/router_connectivity.py
@src/wanctl/autorate_continuous.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PendingRateChange class</name>
  <files>src/wanctl/pending_rates.py, tests/test_pending_rates.py</files>
  <action>
Create new module `src/wanctl/pending_rates.py` with PendingRateChange class:

```python
class PendingRateChange:
    """Track rate changes during router outage for later application."""

    def __init__(self):
        self.pending_dl_rate: int | None = None
        self.pending_ul_rate: int | None = None
        self.queued_at: float | None = None  # monotonic timestamp

    def queue(self, dl_rate: int, ul_rate: int) -> None:
        """Queue a rate change (overwrites previous pending)."""

    def clear(self) -> None:
        """Clear pending changes after successful application."""

    def has_pending(self) -> bool:
        """Check if there are pending changes."""

    def is_stale(self, max_age_seconds: float = 60.0) -> bool:
        """Check if pending rate is older than threshold."""
```

Use time.monotonic() for queued_at timestamp (consistent with router_connectivity.py pattern).

Create comprehensive tests in `tests/test_pending_rates.py`:
- test_queue_stores_rates
- test_queue_overwrites_previous
- test_clear_resets_state
- test_has_pending_false_initially
- test_has_pending_true_after_queue
- test_is_stale_false_when_recent
- test_is_stale_true_after_threshold
- test_is_stale_false_when_no_pending
  </action>
  <verify>
`.venv/bin/pytest tests/test_pending_rates.py -v` passes all tests.
`.venv/bin/mypy src/wanctl/pending_rates.py` passes type checking.
  </verify>
  <done>PendingRateChange class exists with all methods, 8+ tests passing.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate with apply_rate_changes_if_needed</name>
  <files>src/wanctl/autorate_continuous.py, tests/test_autorate_continuous.py</files>
  <action>
Modify WANController in autorate_continuous.py:

1. Add import: `from wanctl.pending_rates import PendingRateChange`

2. In `__init__`, add: `self.pending_rates = PendingRateChange()`

3. Modify `apply_rate_changes_if_needed()` to queue instead of fail when router unreachable:

```python
def apply_rate_changes_if_needed(self, dl_rate: int, ul_rate: int) -> bool:
    # FAIL-CLOSED: Queue rates when router unreachable
    if not self.router_connectivity.is_reachable:
        self.pending_rates.queue(dl_rate, ul_rate)
        self.logger.debug(
            f"{self.wan_name}: Router unreachable, queuing rate change "
            f"(DL={dl_rate/1e6:.1f}Mbps, UL={ul_rate/1e6:.1f}Mbps)"
        )
        return True  # Cycle succeeds - rates queued for later

    # ... existing flash wear and rate limit checks ...

    # After successful router update, clear any pending rates
    self.pending_rates.clear()
```

Insert the router reachability check at the TOP of the method, before flash wear protection. The cycle should return True (success) when queuing - the daemon is healthy, just can't reach router.

4. Add tests in tests/test_autorate_continuous.py:
- test_apply_rate_queues_when_router_unreachable
- test_apply_rate_clears_pending_on_success
- test_apply_rate_returns_true_when_queuing

Note: Do NOT modify run_cycle() yet - pending rate application on reconnection is handled in Plan 02.
  </action>
  <verify>
`.venv/bin/pytest tests/test_autorate_continuous.py -v -k "pending or queue"` passes.
`.venv/bin/pytest tests/ -v` - all existing tests pass (no regressions).
`.venv/bin/mypy src/wanctl/autorate_continuous.py` passes.
  </verify>
  <done>
- apply_rate_changes_if_needed queues rates when router unreachable
- Returns True (cycle success) when queuing
- Clears pending on successful router update
- 3+ new integration tests passing
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make ci` passes (all tests, linting, type checking)
2. PendingRateChange class exists and is tested
3. apply_rate_changes_if_needed queues rates on router failure
4. No rate limits are removed or lost during router outage
</verification>

<success_criteria>
- [ ] PendingRateChange class created with queue/clear/has_pending/is_stale methods
- [ ] 8+ unit tests for PendingRateChange
- [ ] apply_rate_changes_if_needed returns True when queuing (cycle success)
- [ ] Existing tests continue to pass (no regressions)
- [ ] ERRR-03 requirement addressed: rates preserved during router failure
</success_criteria>

<output>
After completion, create `.planning/phases/44-fail-safe-behavior/44-01-SUMMARY.md`
</output>
