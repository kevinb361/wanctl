---
phase: 44-fail-safe-behavior
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - src/wanctl/autorate_continuous.py
  - src/wanctl/router_connectivity.py
  - tests/test_autorate_continuous.py
  - tests/test_router_connectivity.py
autonomous: true

must_haves:
  truths:
    - "Watchdog continues during router-only failures"
    - "Watchdog stops for auth failures (daemon misconfigured)"
    - "Pending rates applied on router reconnection"
    - "Stale rates discarded after 60s outage"
    - "Reconnection log includes outage duration"
  artifacts:
    - path: "src/wanctl/autorate_continuous.py"
      provides: "Watchdog distinction and recovery logic"
      contains: "router_only_failure"
    - path: "src/wanctl/router_connectivity.py"
      provides: "Outage duration calculation"
      contains: "outage_duration"
  key_links:
    - from: "src/wanctl/autorate_continuous.py (main loop)"
      to: "router_connectivity.is_reachable"
      via: "check for router-only failure"
      pattern: "router_only_failure"
    - from: "src/wanctl/autorate_continuous.py (WANController.run_cycle)"
      to: "pending_rates.has_pending"
      via: "apply pending on reconnection after record_success"
      pattern: "self.pending_rates.has_pending"
---

<objective>
Implement watchdog tolerance for router failures and reconnection recovery.

Purpose: Distinguish router failures from daemon failures for watchdog behavior. Router unreachability shouldn't trigger daemon restart - the daemon is healthy, the router is the problem. Also implement recovery behavior to apply queued rates on reconnection. This implements requirement ERRR-04: Watchdog doesn't restart daemon during transient failures.

Output: Modified main loop with watchdog distinction, recovery logic for pending rates, and comprehensive tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-fail-safe-behavior/44-CONTEXT.md
@.planning/phases/44-fail-safe-behavior/44-RESEARCH.md
@.planning/phases/44-fail-safe-behavior/44-01-SUMMARY.md
@src/wanctl/router_connectivity.py
@src/wanctl/autorate_continuous.py
@src/wanctl/pending_rates.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add outage duration tracking to RouterConnectivityState</name>
  <files>src/wanctl/router_connectivity.py, tests/test_router_connectivity.py</files>
  <action>
Enhance RouterConnectivityState to track outage duration:

1. Add `outage_start_time: float | None` attribute (set on first failure)

2. Modify `record_failure()`:
   - Set `outage_start_time = time.monotonic()` only on FIRST failure (when consecutive_failures was 0)
   - Existing logic continues for subsequent failures

3. Add `get_outage_duration() -> float | None` method:
   - Returns None if currently reachable (no active outage)
   - Returns `time.monotonic() - outage_start_time` if in outage

4. Modify `record_success()` to:
   - Calculate and log outage duration: `"Router reconnected after {duration:.1f}s outage ({failures} failures)"`
   - Reset `outage_start_time = None`

5. Update `to_dict()` to include `outage_duration_seconds` (None when reachable)

Add tests in tests/test_router_connectivity.py:
- test_outage_start_time_set_on_first_failure
- test_outage_start_time_not_reset_on_subsequent_failure
- test_get_outage_duration_none_when_reachable
- test_get_outage_duration_returns_elapsed_time
- test_record_success_logs_outage_duration
- test_outage_duration_in_to_dict
  </action>
  <verify>
`.venv/bin/pytest tests/test_router_connectivity.py -v` passes all tests.
`.venv/bin/mypy src/wanctl/router_connectivity.py` passes.
  </verify>
  <done>
- outage_start_time tracked on first failure
- get_outage_duration() method returns elapsed time
- record_success() logs duration on reconnection
- 6+ new tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement watchdog distinction and recovery in WANController</name>
  <files>src/wanctl/autorate_continuous.py, tests/test_autorate_continuous.py</files>
  <action>
**Part A: Add recovery logic to WANController.run_cycle()**

In `WANController.run_cycle()`, IMMEDIATELY AFTER the `self.router_connectivity.record_success()` call (around line 1419), add pending rate recovery:

```python
# Apply pending rates (with flash wear + rate limit protection)
# Track router connectivity state for cycle-level failure detection
try:
    if not self.apply_rate_changes_if_needed(dl_rate, ul_rate):
        # Router communication failed - record failure
        self.router_connectivity.record_failure(
            ConnectionError("Failed to apply rate limits to router")
        )
        return False
    # Router communication succeeded - record success
    self.router_connectivity.record_success()

    # === NEW: Apply pending rates on reconnection ===
    # If we just reconnected and have pending rates, apply them now
    if self.pending_rates.has_pending():
        if self.pending_rates.is_stale():
            self.logger.info(
                f"{self.wan_name}: Discarding stale pending rates "
                f"(queued >{60}s ago)"
            )
            self.pending_rates.clear()
        else:
            self.logger.info(
                f"{self.wan_name}: Applying pending rates after reconnection "
                f"(DL={self.pending_rates.pending_dl_rate/1e6:.1f}Mbps, "
                f"UL={self.pending_rates.pending_ul_rate/1e6:.1f}Mbps)"
            )
            # Note: apply_rate_changes_if_needed clears pending on success
            self.apply_rate_changes_if_needed(
                self.pending_rates.pending_dl_rate,
                self.pending_rates.pending_ul_rate
            )
    # === END NEW ===

except Exception as e:
    # ... existing exception handling ...
```

**Part B: Add watchdog distinction in main() daemon loop**

In `main()`, after the cycle_success/consecutive_failures tracking (around line 1874), add router failure detection:

```python
# Track consecutive failures
if cycle_success:
    consecutive_failures = 0
else:
    consecutive_failures += 1

    # === NEW: Determine if failure is router-only ===
    # Router-only failures: daemon is healthy, router is the problem
    router_only_failure = False
    all_routers_unreachable = all(
        not wan_info["controller"].router_connectivity.is_reachable
        for wan_info in controller.wan_controllers
    )
    any_auth_failure = any(
        wan_info["controller"].router_connectivity.last_failure_type == "auth_failure"
        for wan_info in controller.wan_controllers
    )
    router_only_failure = all_routers_unreachable and not any_auth_failure
    # === END NEW ===

    for wan_info in controller.wan_controllers:
        wan_info["logger"].warning(
            f"Cycle failed ({consecutive_failures}/{MAX_CONSECUTIVE_FAILURES})"
        )
```

Then modify the watchdog notification logic (around line 1895):

```python
# Notify systemd watchdog ONLY if healthy
# === MODIFIED: Continue watchdog during router-only failures ===
if watchdog_enabled and cycle_success:
    notify_watchdog()
elif watchdog_enabled and router_only_failure:
    # Daemon healthy, router problem - keep watchdog alive
    notify_watchdog()
    # Use notify_degraded to indicate router issue without stopping watchdog
    for wan_info in controller.wan_controllers:
        wan_info["logger"].info(
            f"Router unreachable ({consecutive_failures} cycles), watchdog continues"
        )
elif not watchdog_enabled:
    notify_degraded(f"{consecutive_failures} consecutive failures")
# === END MODIFIED ===
```

**Part C: Add tests**

Add tests in tests/test_autorate_continuous.py:
- test_watchdog_continues_during_router_failure
- test_watchdog_stops_on_auth_failure
- test_pending_rates_applied_on_reconnection
- test_stale_pending_rates_discarded
  </action>
  <verify>
`.venv/bin/pytest tests/test_autorate_continuous.py -v -k "watchdog or pending or recovery"` passes.
`.venv/bin/pytest tests/ -v` - all existing tests pass.
`.venv/bin/mypy src/wanctl/autorate_continuous.py` passes.
  </verify>
  <done>
- Watchdog continues during router-only failures
- Watchdog stops on auth_failure (daemon misconfigured)
- Pending rates applied on reconnection (if not stale)
- Stale rates (>60s) discarded with log message
- 4+ new tests passing
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make ci` passes
2. Watchdog notifications continue during router outages
3. Watchdog stops immediately on auth failures
4. Pending rates from Plan 01 are applied on reconnection
5. Long outage (>60s) discards stale rates
6. Reconnection logs include outage duration
</verification>

<success_criteria>
- [ ] Watchdog continues during router-only failures
- [ ] Watchdog stops for auth_failure (daemon needs intervention)
- [ ] Pending rates applied on router reconnection
- [ ] Stale rates (>60s) discarded on reconnection
- [ ] Outage duration included in reconnection log
- [ ] ERRR-04 requirement addressed: watchdog tolerates transient router failures
- [ ] All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/44-fail-safe-behavior/44-02-SUMMARY.md`
</output>
