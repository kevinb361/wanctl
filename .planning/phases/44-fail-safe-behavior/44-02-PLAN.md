---
phase: 44-fail-safe-behavior
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - src/wanctl/autorate_continuous.py
  - src/wanctl/router_connectivity.py
  - tests/test_autorate_continuous.py
  - tests/test_router_connectivity.py
autonomous: true

must_haves:
  truths:
    - "Watchdog continues during router-only failures"
    - "Watchdog stops for auth failures (daemon misconfigured)"
    - "Pending rates applied on router reconnection"
    - "Stale rates discarded after 60s outage"
    - "Reconnection log includes outage duration"
  artifacts:
    - path: "src/wanctl/autorate_continuous.py"
      provides: "Watchdog distinction and recovery logic"
      contains: "router_only_failure"
    - path: "src/wanctl/router_connectivity.py"
      provides: "Outage duration calculation"
      contains: "outage_duration"
  key_links:
    - from: "src/wanctl/autorate_continuous.py (main loop)"
      to: "router_connectivity.is_reachable"
      via: "check for router-only failure"
      pattern: "router_only_failure"
    - from: "src/wanctl/autorate_continuous.py (run_cycle)"
      to: "pending_rates.has_pending"
      via: "apply pending on reconnection"
      pattern: "self.pending_rates.has_pending"
---

<objective>
Implement watchdog tolerance for router failures and reconnection recovery.

Purpose: Distinguish router failures from daemon failures for watchdog behavior. Router unreachability shouldn't trigger daemon restart - the daemon is healthy, the router is the problem. Also implement recovery behavior to apply queued rates on reconnection. This implements requirement ERRR-04: Watchdog doesn't restart daemon during transient failures.

Output: Modified main loop with watchdog distinction, recovery logic for pending rates, and comprehensive tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-fail-safe-behavior/44-CONTEXT.md
@.planning/phases/44-fail-safe-behavior/44-RESEARCH.md
@.planning/phases/44-fail-safe-behavior/44-01-SUMMARY.md
@src/wanctl/router_connectivity.py
@src/wanctl/autorate_continuous.py
@src/wanctl/pending_rates.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add outage duration tracking to RouterConnectivityState</name>
  <files>src/wanctl/router_connectivity.py, tests/test_router_connectivity.py</files>
  <action>
Enhance RouterConnectivityState to track outage duration:

1. Add `outage_start_time: float | None` attribute (set on first failure)

2. Modify `record_failure()`:
   - Set `outage_start_time = time.monotonic()` only on FIRST failure (when consecutive_failures was 0)
   - Existing logic continues for subsequent failures

3. Add `get_outage_duration() -> float | None` method:
   - Returns None if currently reachable (no active outage)
   - Returns `time.monotonic() - outage_start_time` if in outage

4. Modify `record_success()` to:
   - Calculate and log outage duration: `"Router reconnected after {duration:.1f}s outage ({failures} failures)"`
   - Reset `outage_start_time = None`

5. Update `to_dict()` to include `outage_duration_seconds` (None when reachable)

Add tests in tests/test_router_connectivity.py:
- test_outage_start_time_set_on_first_failure
- test_outage_start_time_not_reset_on_subsequent_failure
- test_get_outage_duration_none_when_reachable
- test_get_outage_duration_returns_elapsed_time
- test_record_success_logs_outage_duration
- test_outage_duration_in_to_dict
  </action>
  <verify>
`.venv/bin/pytest tests/test_router_connectivity.py -v` passes all tests.
`.venv/bin/mypy src/wanctl/router_connectivity.py` passes.
  </verify>
  <done>
- outage_start_time tracked on first failure
- get_outage_duration() method returns elapsed time
- record_success() logs duration on reconnection
- 6+ new tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement watchdog distinction and recovery in main loop</name>
  <files>src/wanctl/autorate_continuous.py, tests/test_autorate_continuous.py</files>
  <action>
Modify the main daemon loop in `run_autorate_continuous()`:

1. After existing cycle_success/consecutive_failures tracking, add router failure detection:

```python
# Determine if failure is router-only (daemon healthy, router problem)
router_only_failure = False
if not cycle_success:
    # Check if ALL WANs have router connectivity issues
    all_routers_unreachable = all(
        not wan_info["controller"].router_connectivity.is_reachable
        for wan_info in controller.wan_controllers
    )
    # Check if last failure was auth (daemon misconfigured - should restart)
    any_auth_failure = any(
        wan_info["controller"].router_connectivity.last_failure_type == "auth_failure"
        for wan_info in controller.wan_controllers
    )
    router_only_failure = all_routers_unreachable and not any_auth_failure
```

2. Modify watchdog logic to continue during router-only failures:

```python
# WATCHDOG POLICY:
# - Router-only failures: Continue watchdog (daemon is healthy)
# - Auth failures: Stop watchdog (daemon misconfigured)
# - Other failures: Stop watchdog after threshold
if cycle_success:
    consecutive_failures = 0
    notify_watchdog()
elif router_only_failure:
    # Daemon healthy, router problem - keep watchdog alive
    notify_watchdog()
    notify_status(f"Router unreachable ({consecutive_failures} cycles)")
elif consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
    if watchdog_enabled:
        watchdog_enabled = False
        # ... existing error logging ...
        notify_degraded("consecutive failures exceeded threshold")
```

3. Add recovery logic in run_cycle() to apply pending rates on reconnection:

In the section after router communication succeeds (after router_connectivity.record_success()):

```python
# Apply pending rates if we just reconnected
for wan_info in self.wan_controllers:
    controller = wan_info["controller"]
    if controller.pending_rates.has_pending():
        if controller.pending_rates.is_stale():
            controller.logger.info(
                f"{controller.wan_name}: Discarding stale pending rates "
                f"(queued {controller.pending_rates.queued_at - time.monotonic():.0f}s ago)"
            )
            controller.pending_rates.clear()
        else:
            # Apply pending rates
            controller.apply_rate_changes_if_needed(
                controller.pending_rates.pending_dl_rate,
                controller.pending_rates.pending_ul_rate
            )
            # Note: apply_rate_changes_if_needed clears pending on success
```

Wait - this should be in WANController, not the main loop. Let me revise:

Actually, the recovery logic should be in WANController.run_cycle() after a successful router communication, not in the main loop. Check where router_connectivity.record_success() is called and add recovery there.

Add tests:
- test_watchdog_continues_during_router_failure
- test_watchdog_stops_on_auth_failure
- test_pending_rates_applied_on_reconnection
- test_stale_pending_rates_discarded
  </action>
  <verify>
`.venv/bin/pytest tests/test_autorate_continuous.py -v -k "watchdog or pending or recovery"` passes.
`.venv/bin/pytest tests/ -v` - all existing tests pass.
`.venv/bin/mypy src/wanctl/autorate_continuous.py` passes.
  </verify>
  <done>
- Watchdog continues during router-only failures
- Watchdog stops on auth_failure (daemon misconfigured)
- Pending rates applied on reconnection (if not stale)
- Stale rates (>60s) discarded with log message
- 4+ new tests passing
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make ci` passes
2. Watchdog notifications continue during router outages
3. Watchdog stops immediately on auth failures
4. Pending rates from Plan 01 are applied on reconnection
5. Long outage (>60s) discards stale rates
6. Reconnection logs include outage duration
</verification>

<success_criteria>
- [ ] Watchdog continues during router-only failures
- [ ] Watchdog stops for auth_failure (daemon needs intervention)
- [ ] Pending rates applied on router reconnection
- [ ] Stale rates (>60s) discarded on reconnection
- [ ] Outage duration included in reconnection log
- [ ] ERRR-04 requirement addressed: watchdog tolerates transient router failures
- [ ] All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/44-fail-safe-behavior/44-02-SUMMARY.md`
</output>
