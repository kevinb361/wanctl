---
phase: 32-backend-client-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_routeros_rest.py
autonomous: true

must_haves:
  truths:
    - "REST client constructor creates session with correct auth and SSL settings"
    - "run_cmd returns (0, json, '') on successful HTTP response"
    - "run_cmd returns (1, '', error) on network failure"
    - "Queue tree set/print commands work via REST API"
    - "Mangle rule enable/disable commands work via REST API"
    - "ID caching reduces redundant API lookups"
    - "set_queue_limit and get_queue_stats work correctly"
    - "test_connection returns True on success, False on failure"
    - "close() safely closes session"
  artifacts:
    - path: "tests/test_routeros_rest.py"
      provides: "Comprehensive REST client tests"
      min_lines: 300
  key_links:
    - from: "tests/test_routeros_rest.py"
      to: "src/wanctl/routeros_rest.py"
      via: "pytest imports and tests"
      pattern: "from wanctl.routeros_rest import"
---

<objective>
Create comprehensive unit tests for RouterOSREST client achieving >= 90% coverage.

Purpose: BACK-01, BACK-02 - REST API client must have thorough test coverage including happy paths, error handling, retry logic, and edge cases.
Output: tests/test_routeros_rest.py with mocked requests.Session
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-backend-client-tests/32-RESEARCH.md
@src/wanctl/routeros_rest.py
@tests/test_router_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REST client test fixtures and constructor tests</name>
  <files>tests/test_routeros_rest.py</files>
  <action>
Create tests/test_routeros_rest.py with:

1. Test fixtures (following patterns from test_router_client.py):
```python
@pytest.fixture
def mock_session():
    """Create mock requests Session with standard response."""
    session = MagicMock()
    response = MagicMock()
    response.ok = True
    response.json.return_value = []
    session.get.return_value = response
    session.patch.return_value = response
    session.post.return_value = response
    return session

@pytest.fixture
def rest_client(mock_session):
    """Create REST client with mocked session."""
    with patch("wanctl.routeros_rest.requests.Session") as mock_class:
        mock_class.return_value = mock_session
        client = RouterOSREST(
            host="192.168.1.1",
            user="admin",
            password="test",  # pragma: allowlist secret
        )
    client._session = mock_session
    return client
```

2. Constructor tests (TestRouterOSRESTInit class):
- test_default_port_443_uses_https: Default port 443 creates https URL
- test_custom_port_80_uses_http: Port 80 creates http URL
- test_session_auth_configured: Session has correct (user, password) auth
- test_session_verify_ssl_false_default: verify=False by default
- test_session_verify_ssl_true: verify=True when configured
- test_custom_timeout: Custom timeout stored correctly
- test_logger_provided: Uses provided logger
- test_logger_default: Creates default logger when none provided
- test_caches_initialized_empty: _queue_id_cache and _mangle_id_cache start empty

3. from_config class method tests:
- test_from_config_basic: Creates client from config object
- test_from_config_env_password: Expands ${VAR} password from environment
- test_from_config_default_port: Uses 443 when not specified
- test_from_config_custom_timeout: Uses timeout_ssh_command from config
  </action>
  <verify>
`.venv/bin/pytest tests/test_routeros_rest.py -v --tb=short` passes all constructor tests
  </verify>
  <done>
Constructor and from_config tests pass, fixtures work correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add run_cmd and command parsing tests</name>
  <files>tests/test_routeros_rest.py</files>
  <action>
Add to tests/test_routeros_rest.py:

1. run_cmd tests (TestRouterOSRESTRunCmd class):
- test_run_cmd_success_returns_json: Successful response returns (0, json_string, '')
- test_run_cmd_network_error: RequestException returns (1, '', error_message)
- test_run_cmd_unexpected_error: Generic exception returns (1, '', error_message)
- test_run_cmd_uses_custom_timeout: Timeout parameter passed to _execute_command
- test_run_cmd_unsupported_command: Unsupported commands return (1, '', 'Command failed')
- test_run_cmd_batched_commands: Commands with semicolons execute in sequence

2. Parsing helper tests (TestParsing class):
- test_parse_find_name_extracts_name: '[find name="WAN-Download"]' -> 'WAN-Download'
- test_parse_find_name_no_match: Returns None when pattern not found
- test_parse_find_comment_extracts_comment: '[find comment="steering"]' -> 'steering'
- test_parse_find_comment_no_match: Returns None when pattern not found
- test_parse_parameters_extracts_queue: 'queue=cake-down' extracted
- test_parse_parameters_extracts_max_limit: 'max-limit=500000000' extracted
- test_parse_parameters_extracts_both: Multiple params extracted
- test_parse_parameters_empty_cmd: Returns empty dict

3. Command handler tests (TestQueueTreeSet class):
- test_handle_queue_tree_set_success: Updates queue with PATCH
- test_handle_queue_tree_set_no_name: Returns None when name missing
- test_handle_queue_tree_set_no_params: Returns None when no params
- test_handle_queue_tree_set_queue_not_found: Returns None when queue doesn't exist
- test_handle_queue_tree_set_patch_failure: Returns None on HTTP error

Mock patterns:
- Mock _find_queue_id to return "*1" or None
- Mock session.patch response.ok to True or False
  </action>
  <verify>
`.venv/bin/pytest tests/test_routeros_rest.py::TestRouterOSRESTRunCmd -v` and `::TestParsing` and `::TestQueueTreeSet` all pass
  </verify>
  <done>
run_cmd, parsing helpers, and queue tree set tests all pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add remaining command handlers and utility method tests</name>
  <files>tests/test_routeros_rest.py</files>
  <action>
Add to tests/test_routeros_rest.py:

1. Queue reset counters tests (TestQueueResetCounters class):
- test_handle_queue_reset_counters_success: POST to reset-counters endpoint
- test_handle_queue_reset_counters_find_name: Parses [find name="..."]
- test_handle_queue_reset_counters_where_name: Parses where name="..."
- test_handle_queue_reset_counters_no_name: Returns None
- test_handle_queue_reset_counters_queue_not_found: Returns None
- test_handle_queue_reset_counters_post_failure: Returns None on HTTP error

2. Queue tree print tests (TestQueueTreePrint class):
- test_handle_queue_tree_print_all: GET without filter
- test_handle_queue_tree_print_filtered: GET with name param
- test_handle_queue_tree_print_failure: Returns None on HTTP error

3. Mangle rule tests (TestMangleRule class):
- test_handle_mangle_rule_enable: Sets disabled=false
- test_handle_mangle_rule_disable: Sets disabled=true
- test_handle_mangle_rule_no_comment: Returns None
- test_handle_mangle_rule_unknown_action: Returns None when neither enable/disable
- test_handle_mangle_rule_not_found: Returns None when rule doesn't exist
- test_handle_mangle_rule_patch_failure: Returns None on HTTP error

4. Resource ID lookup tests (TestResourceIdLookup class):
- test_find_resource_id_cache_hit: Returns cached ID without API call
- test_find_resource_id_cache_miss_then_hit: Caches result for next call
- test_find_resource_id_no_cache: use_cache=False always queries API
- test_find_resource_id_not_found: Returns None when resource missing
- test_find_resource_id_network_error: Returns None on RequestException
- test_find_queue_id_uses_queue_cache: Uses _queue_id_cache
- test_find_mangle_rule_id_uses_mangle_cache: Uses _mangle_id_cache

5. High-level API tests (TestHighLevelAPI class):
- test_set_queue_limit_success: Updates queue limit via PATCH
- test_set_queue_limit_queue_not_found: Returns False
- test_set_queue_limit_patch_failure: Returns False on HTTP error
- test_get_queue_stats_success: Returns queue dict from GET
- test_get_queue_stats_not_found: Returns None when queue missing
- test_get_queue_stats_network_error: Returns None on RequestException
- test_test_connection_success: Returns True on ok response
- test_test_connection_failure: Returns False on network error
- test_close_closes_session: Calls session.close()
- test_close_safe_when_no_session: Handles None session
- test_close_safe_on_exception: Handles exception during close

6. Verify coverage:
Run: `.venv/bin/pytest tests/test_routeros_rest.py --cov=wanctl.routeros_rest --cov-report=term-missing`
Target: >= 90% coverage on routeros_rest.py
  </action>
  <verify>
- `.venv/bin/pytest tests/test_routeros_rest.py -v` passes all tests
- `.venv/bin/pytest tests/test_routeros_rest.py --cov=wanctl.routeros_rest --cov-report=term` shows >= 90% coverage
  </verify>
  <done>
- All REST client tests pass
- routeros_rest.py coverage >= 90%
  </done>
</task>

</tasks>

<verification>
1. All tests pass: `.venv/bin/pytest tests/test_routeros_rest.py -v`
2. Coverage check: `.venv/bin/pytest tests/test_routeros_rest.py --cov=wanctl.routeros_rest --cov-fail-under=90`
3. No regressions: `.venv/bin/pytest tests/ -q`
</verification>

<success_criteria>
- tests/test_routeros_rest.py exists with 300+ lines of tests
- routeros_rest.py coverage >= 90%
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/32-backend-client-tests/32-01-SUMMARY.md`
</output>
