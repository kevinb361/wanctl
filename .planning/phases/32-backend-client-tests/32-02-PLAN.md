---
phase: 32-backend-client-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_routeros_ssh.py
  - tests/test_backends.py
autonomous: true

must_haves:
  truths:
    - "SSH client constructor creates paramiko client with correct settings"
    - "run_cmd executes command and returns (rc, stdout, stderr)"
    - "run_cmd reconnects automatically when connection lost"
    - "SSH client handles network errors gracefully"
    - "close() safely closes SSH connection"
    - "RouterBackend base class abstract methods enforced"
    - "RouterBackend default implementations work correctly"
    - "RouterOSBackend from_config creates instance correctly"
    - "RouterOSBackend methods delegate to SSH client"
  artifacts:
    - path: "tests/test_routeros_ssh.py"
      provides: "Comprehensive SSH client tests"
      min_lines: 200
    - path: "tests/test_backends.py"
      provides: "Backend abstraction tests"
      min_lines: 150
  key_links:
    - from: "tests/test_routeros_ssh.py"
      to: "src/wanctl/routeros_ssh.py"
      via: "pytest imports and tests"
      pattern: "from wanctl.routeros_ssh import"
    - from: "tests/test_backends.py"
      to: "src/wanctl/backends/base.py"
      via: "pytest imports and tests"
      pattern: "from wanctl.backends.base import"
---

<objective>
Create comprehensive unit tests for RouterOSSSH client and backend abstraction layer achieving >= 90% coverage.

Purpose: BACK-03, BACK-04, BACK-05, BACK-06 - SSH client and backend abstraction must have thorough test coverage including connection management, command execution, error handling, and abstract method enforcement.
Output: tests/test_routeros_ssh.py and tests/test_backends.py with mocked paramiko.SSHClient
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-backend-client-tests/32-RESEARCH.md
@src/wanctl/routeros_ssh.py
@src/wanctl/backends/base.py
@src/wanctl/backends/routeros.py
@tests/test_router_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSH client test fixtures and constructor tests</name>
  <files>tests/test_routeros_ssh.py</files>
  <action>
Create tests/test_routeros_ssh.py with:

1. Test fixtures (following patterns from research):
```python
import logging
from pathlib import Path
from unittest.mock import MagicMock, patch, PropertyMock

import pytest
import paramiko

from wanctl.routeros_ssh import RouterOSSSH


@pytest.fixture
def mock_ssh_client():
    """Create mock paramiko SSHClient with active transport."""
    client = MagicMock(spec=paramiko.SSHClient)
    transport = MagicMock()
    transport.is_active.return_value = True
    client.get_transport.return_value = transport

    # Mock exec_command return values
    stdin = MagicMock()
    stdout = MagicMock()
    stderr = MagicMock()
    stdout.read.return_value = b"output"
    stderr.read.return_value = b""
    stdout.channel.recv_exit_status.return_value = 0
    client.exec_command.return_value = (stdin, stdout, stderr)

    return client


@pytest.fixture
def ssh_client(mock_ssh_client, tmp_path):
    """Create SSH client with mocked paramiko."""
    # Create dummy key file
    key_file = tmp_path / "test_key"
    key_file.touch()

    with patch("wanctl.routeros_ssh.paramiko.SSHClient") as mock_class:
        mock_class.return_value = mock_ssh_client
        client = RouterOSSSH(
            host="192.168.1.1",
            user="admin",
            ssh_key=str(key_file),
        )
    return client
```

2. Constructor tests (TestRouterOSSSHInit class):
- test_stores_host: host attribute set correctly
- test_stores_user: user attribute set correctly
- test_stores_ssh_key: ssh_key attribute set correctly
- test_default_timeout_15: timeout defaults to 15 seconds
- test_custom_timeout: custom timeout stored correctly
- test_logger_provided: uses provided logger
- test_logger_default: creates default logger when none provided
- test_client_initially_none: _client is None before connection

3. from_config class method tests:
- test_from_config_basic: creates client from config object
- test_from_config_default_timeout: uses 15 when not specified
- test_from_config_custom_timeout: uses timeout_ssh_command from config

4. _get_known_hosts_path tests:
- test_known_hosts_path_returns_path: returns Path object
- test_known_hosts_path_creates_ssh_dir: creates ~/.ssh if missing (use tmp_path)
- test_known_hosts_path_creates_file: creates known_hosts if missing
  </action>
  <verify>
`.venv/bin/pytest tests/test_routeros_ssh.py -v --tb=short` passes all constructor tests
  </verify>
  <done>
Constructor and from_config tests pass, fixtures work correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add connection and run_cmd tests</name>
  <files>tests/test_routeros_ssh.py</files>
  <action>
Add to tests/test_routeros_ssh.py:

1. Connection tests (TestConnection class):
- test_connect_creates_client: _connect creates SSHClient instance
- test_connect_loads_host_keys: calls load_system_host_keys and load_host_keys
- test_connect_sets_reject_policy: sets RejectPolicy for host key validation
- test_connect_calls_connect: calls connect with correct params
- test_is_connected_false_when_no_client: _is_connected returns False when _client is None
- test_is_connected_false_when_no_transport: returns False when get_transport returns None
- test_is_connected_false_when_inactive: returns False when is_active returns False
- test_is_connected_true_when_active: returns True when transport is active
- test_ensure_connected_connects_when_disconnected: calls _connect when not connected
- test_ensure_connected_noop_when_connected: doesn't reconnect when already connected
- test_ensure_connected_reconnects_on_lost_connection: reconnects when transport inactive

2. run_cmd tests (TestRunCmd class):
- test_run_cmd_success: returns (0, stdout, stderr) on success
- test_run_cmd_capture_true: returns decoded output when capture=True
- test_run_cmd_capture_false: returns empty strings when capture=False (but drains channels)
- test_run_cmd_custom_timeout: passes timeout to exec_command
- test_run_cmd_nonzero_exit: returns non-zero exit status
- test_run_cmd_ensures_connected: calls _ensure_connected before exec
- test_run_cmd_ssh_exception_clears_client: SSHException sets _client to None
- test_run_cmd_ssh_exception_raises: SSHException propagates after clearing client
- test_run_cmd_decodes_utf8: decodes output with utf-8
- test_run_cmd_handles_decode_errors: uses errors='replace' for bad bytes

3. close tests (TestClose class):
- test_close_closes_client: calls _client.close()
- test_close_sets_client_none: sets _client to None after close
- test_close_safe_when_no_client: doesn't raise when _client is None
- test_close_safe_on_exception: handles exception during close
- test_close_logs_debug: logs debug message on close
  </action>
  <verify>
`.venv/bin/pytest tests/test_routeros_ssh.py::TestConnection -v` and `::TestRunCmd` and `::TestClose` all pass
  </verify>
  <done>
Connection, run_cmd, and close tests all pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create backend abstraction tests</name>
  <files>tests/test_backends.py</files>
  <action>
Create tests/test_backends.py with:

1. Base class tests (TestRouterBackend class):
```python
import logging
from abc import ABC
from unittest.mock import MagicMock, patch

import pytest

from wanctl.backends.base import RouterBackend
from wanctl.backends.routeros import RouterOSBackend


class ConcreteBackend(RouterBackend):
    """Minimal concrete implementation for testing abstract base."""

    def set_bandwidth(self, queue: str, rate_bps: int) -> bool:
        return True

    def get_bandwidth(self, queue: str) -> int | None:
        return 1000000

    def get_queue_stats(self, queue: str) -> dict | None:
        return {"packets": 100, "bytes": 1000}

    def enable_rule(self, comment: str) -> bool:
        return True

    def disable_rule(self, comment: str) -> bool:
        return True

    def is_rule_enabled(self, comment: str) -> bool | None:
        return True
```

- test_cannot_instantiate_abstract: RouterBackend() raises TypeError
- test_concrete_can_instantiate: ConcreteBackend() works
- test_logger_provided: uses provided logger
- test_logger_default: creates default logger when none provided
- test_reset_queue_counters_default_true: default returns True
- test_test_connection_default_true: default returns True
- test_from_config_not_implemented: raises NotImplementedError

2. RouterOSBackend tests (TestRouterOSBackend class):

Fixtures:
```python
@pytest.fixture
def mock_ssh():
    """Create mock RouterOSSSH."""
    ssh = MagicMock()
    ssh.run_cmd.return_value = (0, "", "")
    return ssh

@pytest.fixture
def backend(mock_ssh):
    """Create RouterOSBackend with mocked SSH."""
    with patch("wanctl.backends.routeros.RouterOSSSH") as mock_class:
        mock_class.return_value = mock_ssh
        backend = RouterOSBackend(
            host="192.168.1.1",
            user="admin",
            ssh_key="/path/to/key",
        )
    backend.ssh = mock_ssh
    return backend
```

- test_from_config_creates_backend: from_config creates instance with correct params
- test_from_config_default_timeout: uses 15 when config.timeouts missing
- test_from_config_custom_timeout: uses config.timeouts['ssh_command']

3. RouterOSBackend method tests:
- test_set_bandwidth_success: returns True on rc=0
- test_set_bandwidth_failure: returns False on rc!=0
- test_set_bandwidth_runs_correct_command: SSH gets correct command string
- test_get_bandwidth_success: parses max-limit from output
- test_get_bandwidth_failure: returns None on rc!=0
- test_get_bandwidth_unlimited: returns 0 for max-limit=0
- test_get_queue_stats_success: parses stats from output (mock extract_queue_stats)
- test_get_queue_stats_failure: returns None on rc!=0
- test_enable_rule_success: returns True on rc=0
- test_enable_rule_failure: returns False on rc!=0
- test_disable_rule_success: returns True on rc=0
- test_disable_rule_failure: returns False on rc!=0
- test_is_rule_enabled_true: returns True when not disabled
- test_is_rule_enabled_false: returns False when X flag present
- test_is_rule_enabled_not_found: returns None when empty output
- test_is_rule_enabled_error: returns None on rc!=0
- test_reset_queue_counters_success: returns True on rc=0
- test_reset_queue_counters_failure: returns False on rc!=0
- test_test_connection_success: returns True when identity command succeeds
- test_test_connection_failure: returns False on rc!=0 or empty output
  </action>
  <verify>
`.venv/bin/pytest tests/test_backends.py -v` passes all tests
  </verify>
  <done>
All backend abstraction tests pass
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify coverage and run full test suite</name>
  <files>tests/test_routeros_ssh.py, tests/test_backends.py</files>
  <action>
1. Run coverage for SSH client:
`.venv/bin/pytest tests/test_routeros_ssh.py --cov=wanctl.routeros_ssh --cov-report=term-missing`
Target: >= 90% coverage

2. Run coverage for backends:
`.venv/bin/pytest tests/test_backends.py --cov=wanctl.backends.base --cov=wanctl.backends.routeros --cov-report=term-missing`
Target: >= 90% coverage on both files

3. If coverage gaps exist, add additional tests:
- Look at MISSING column in coverage report
- Add tests for uncovered lines/branches
- Common gaps: error handling branches, edge cases

4. Run full test suite to verify no regressions:
`.venv/bin/pytest tests/ -q`

5. Verify combined coverage for all Phase 32 modules:
`.venv/bin/pytest tests/test_routeros_rest.py tests/test_routeros_ssh.py tests/test_backends.py --cov=wanctl.routeros_rest --cov=wanctl.routeros_ssh --cov=wanctl.backends.base --cov=wanctl.backends.routeros --cov-report=term`
  </action>
  <verify>
- routeros_ssh.py coverage >= 90%
- backends/base.py coverage >= 90%
- backends/routeros.py coverage >= 90%
- All existing tests still pass
  </verify>
  <done>
- All backend client tests pass
- routeros_ssh.py, backends/base.py, backends/routeros.py all >= 90% coverage
- No test regressions
  </done>
</task>

</tasks>

<verification>
1. All tests pass: `.venv/bin/pytest tests/test_routeros_ssh.py tests/test_backends.py -v`
2. SSH coverage: `.venv/bin/pytest tests/test_routeros_ssh.py --cov=wanctl.routeros_ssh --cov-fail-under=90`
3. Backend coverage: `.venv/bin/pytest tests/test_backends.py --cov=wanctl.backends.base --cov=wanctl.backends.routeros --cov-fail-under=90`
4. No regressions: `.venv/bin/pytest tests/ -q`
</verification>

<success_criteria>
- tests/test_routeros_ssh.py exists with 200+ lines of tests
- tests/test_backends.py exists with 150+ lines of tests
- routeros_ssh.py coverage >= 90%
- backends/base.py coverage >= 90%
- backends/routeros.py coverage >= 90%
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/32-backend-client-tests/32-02-SUMMARY.md`
</output>
