---
phase: 36-steering-daemon-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_steering_daemon.py
autonomous: true

must_haves:
  truths:
    - "run_cycle() executes full steering cycle including baseline update, RTT measurement, EWMA, and state machine update"
    - "main() entry point handles argument parsing, config loading, health server lifecycle, and graceful shutdown"
    - "Confidence controller integration works in both dry-run and live modes"
  artifacts:
    - path: "tests/test_steering_daemon.py"
      provides: "TestRunCycle, TestMainEntryPoint, TestConfidenceIntegration classes"
      contains: "class TestRunCycle"
  key_links:
    - from: "tests/test_steering_daemon.py"
      to: "wanctl.steering.daemon.main"
      via: "import and patch"
      pattern: "from wanctl.steering.daemon import main"
---

<objective>
Test run_cycle(), main() entry point, and confidence controller integration paths for lines 1002-1236 and 1354-1479.

Purpose: Cover high-level steering daemon functionality including the main control loop, entry point lifecycle, and confidence-based steering decisions.
Output: Three new test classes (TestRunCycle, TestMainEntryPoint, TestConfidenceIntegration) with ~25 tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-steering-daemon-tests/36-CONTEXT.md
@.planning/phases/36-steering-daemon-tests/36-RESEARCH.md
@src/wanctl/steering/daemon.py
@tests/test_steering_daemon.py
@tests/test_steering_health.py (health server test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TestRunCycle and TestConfidenceIntegration tests</name>
  <files>tests/test_steering_daemon.py</files>
  <action>
Add TestRunCycle class testing run_cycle() method:

1. **Success paths:**
   - Full cycle: baseline loads, RTT measured, EWMA updated, state machine runs, state saved
   - CAKE-aware mode: logs include congestion state
   - Legacy mode (cake_aware=False): logs include bad_count/good_count
   - State change triggers transition log

2. **Failure paths:**
   - Baseline RTT unavailable: returns False, logs error
   - RTT measurement fails after retries: returns False, logs warning
   - State machine failure doesn't prevent save

3. **Metrics integration:**
   - record_steering_state called when metrics_enabled=True
   - Metrics not called when metrics_enabled=False

Mock pattern (full daemon with mocked dependencies):
```python
@pytest.fixture
def daemon_for_run_cycle(self, mock_config, mock_state_mgr, mock_router, mock_logger):
    daemon = SteeringDaemon(
        mock_config, mock_state_mgr, mock_router,
        MagicMock(), MagicMock(), mock_logger
    )
    daemon.update_baseline_rtt = MagicMock(return_value=True)
    daemon.collect_cake_stats = MagicMock(return_value=(5, 20))
    daemon._measure_current_rtt_with_retry = MagicMock(return_value=30.0)
    daemon.state_mgr.state["baseline_rtt"] = 25.0
    return daemon
```

Add TestConfidenceIntegration class testing confidence controller paths:

1. **Dry-run mode (production default):**
   - ConfidenceController.evaluate() called with ConfidenceSignals
   - Returns decision but does NOT apply routing (falls through to hysteresis)
   - Logs confidence decision for observability

2. **Live mode (dry_run=False):**
   - ENABLE_STEERING decision: calls execute_steering_transition to enable
   - DISABLE_STEERING decision: calls execute_steering_transition to disable
   - None decision: falls through to hysteresis

3. **_apply_confidence_decision():**
   - ENABLE_STEERING: transitions to state_degraded, enables routing
   - DISABLE_STEERING: transitions to state_good, disables routing
   - Invalid decision returns False

Mock pattern:
```python
def test_confidence_live_mode_enables_steering(self, daemon_with_confidence, mock_router):
    daemon_with_confidence.config.confidence_config = {
        "dry_run": {"enabled": False},
        "thresholds": {...}
    }
    daemon_with_confidence.confidence_controller = MagicMock()
    daemon_with_confidence.confidence_controller.evaluate.return_value = "ENABLE_STEERING"

    signals = CongestionSignals(
        rtt_delta=50.0, rtt_delta_ewma=50.0,
        cake_drops=10, queued_packets=100, baseline_rtt=25.0
    )

    result = daemon_with_confidence.update_state_machine(signals)

    assert result is True
    mock_router.enable_steering.assert_called_once()
```
  </action>
  <verify>`.venv/bin/pytest tests/test_steering_daemon.py::TestRunCycle tests/test_steering_daemon.py::TestConfidenceIntegration -v` passes</verify>
  <done>run_cycle() and confidence integration paths have 90%+ coverage</done>
</task>

<task type="auto">
  <name>Task 2: Add TestMainEntryPoint tests</name>
  <files>tests/test_steering_daemon.py</files>
  <action>
Add TestMainEntryPoint class testing main() function:

1. **Argument parsing:**
   - --config required: missing raises error
   - --reset flag triggers reset mode
   - --debug flag enables debug logging

2. **Config loading:**
   - Valid config loads successfully
   - Invalid YAML returns exit code 1
   - Missing config file returns exit code 1

3. **Lock handling:**
   - Lock acquired successfully: daemon starts
   - Lock conflict (another instance): returns 1
   - Lock cleanup in finally block

4. **Health server lifecycle:**
   - Health server starts before daemon loop
   - Health server shuts down in finally block
   - Health server failure doesn't prevent daemon start (logs warning)

5. **Shutdown handling:**
   - Early shutdown (signal during startup): returns 0
   - KeyboardInterrupt: returns 130
   - Unhandled exception: returns 1, logs traceback
   - Exception during shutdown: returns 0

6. **Reset mode:**
   - --reset: state_mgr.reset() called, router.disable_steering() called, returns 0

Mock pattern (patch at import boundaries):
```python
def test_main_invalid_config_returns_1(self, tmp_path):
    bad_config = tmp_path / "bad.yaml"
    bad_config.write_text("invalid: yaml: [")

    with patch("sys.argv", ["steering-daemon", "--config", str(bad_config)]):
        with patch("wanctl.steering.daemon.register_signal_handlers"):
            result = main()

    assert result == 1

def test_main_health_server_lifecycle(self, tmp_path, valid_config_file):
    with patch("sys.argv", ["steering-daemon", "--config", str(valid_config_file)]):
        with patch("wanctl.steering.daemon.register_signal_handlers"):
            with patch("wanctl.steering.daemon.start_steering_health_server") as mock_health:
                mock_server = MagicMock()
                mock_health.return_value = mock_server
                with patch("wanctl.steering.daemon.run_daemon_loop", return_value=0):
                    with patch("wanctl.steering.daemon.validate_and_acquire_lock", return_value=True):
                        result = main()

                mock_health.assert_called_once()
                mock_server.shutdown.assert_called_once()
                assert result == 0
```

Create valid_config_file fixture with minimal required fields:
```python
@pytest.fixture
def valid_config_file(self, tmp_path):
    config_file = tmp_path / "config.yaml"
    config_file.write_text("""
primary_wan: spectrum
alternate_wan: att
router:
  host: "10.10.99.1"
  password: "test"
  transport: "rest"
""")
    return config_file
```
  </action>
  <verify>`.venv/bin/pytest tests/test_steering_daemon.py::TestMainEntryPoint -v` passes</verify>
  <done>main() entry point has 90%+ coverage including health server, lock, and shutdown paths</done>
</task>

</tasks>

<verification>
Run full coverage check:
```bash
.venv/bin/pytest tests/test_steering_daemon.py --cov=wanctl.steering.daemon --cov-report=term-missing 2>&1 | grep -E "daemon.py.*%"
```

Target: 90%+ coverage (up from 44.2%)

Verify key line ranges covered:
- Lines 1002-1062 (confidence integration)
- Lines 1149-1236 (run_cycle)
- Lines 1354-1479 (main entry point)
</verification>

<success_criteria>
1. TestRunCycle class with ~8 tests for full cycle and failure paths
2. TestConfidenceIntegration class with ~8 tests for dry-run and live mode
3. TestMainEntryPoint class with ~12 tests for entry point lifecycle
4. Total daemon.py coverage >= 90% (from 44.2%)
5. All tests pass: `.venv/bin/pytest tests/test_steering_daemon.py -v`
</success_criteria>

<output>
After completion, create `.planning/phases/36-steering-daemon-tests/36-02-SUMMARY.md`
</output>
