---
phase: 43-error-detection-reconnection
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - src/wanctl/autorate_continuous.py
  - src/wanctl/steering/daemon.py
  - tests/test_autorate_error_recovery.py
  - tests/integration/test_steering_daemon.py
autonomous: true

must_haves:
  truths:
    - "WANController tracks router connectivity state across cycles"
    - "SteeringDaemon tracks router connectivity state across cycles"
    - "Router communication failures are classified and logged with failure type"
    - "Reconnection after outage is logged with failure count"
    - "EWMA/baseline state is preserved across reconnection (not reset)"
  artifacts:
    - path: "src/wanctl/autorate_continuous.py"
      provides: "WANController with router_connectivity tracking"
      contains: "RouterConnectivityState"
    - path: "src/wanctl/steering/daemon.py"
      provides: "SteeringDaemon with router_connectivity tracking"
      contains: "RouterConnectivityState"
  key_links:
    - from: "src/wanctl/autorate_continuous.py"
      to: "src/wanctl/router_connectivity.py"
      via: "import and instantiation"
      pattern: "from wanctl.router_connectivity import"
    - from: "src/wanctl/steering/daemon.py"
      to: "src/wanctl/router_connectivity.py"
      via: "import and instantiation"
      pattern: "from wanctl.router_connectivity import"
---

<objective>
Integrate RouterConnectivityState into WANController and SteeringDaemon for cycle-level router connectivity tracking.

Purpose: Both daemons need to track router reachability across cycles to distinguish transient errors from sustained outages, log appropriately, and recover gracefully.

Output: Updated daemon code with connectivity tracking and new tests.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/43-error-detection-reconnection/43-RESEARCH.md
@.planning/phases/43-error-detection-reconnection/43-01-SUMMARY.md

@src/wanctl/autorate_continuous.py (WANController class)
@src/wanctl/steering/daemon.py (SteeringDaemon class)
@src/wanctl/router_connectivity.py (RouterConnectivityState - from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate RouterConnectivityState into WANController</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
    Add RouterConnectivityState to WANController:

    1. Add import at top of file:
       ```python
       from wanctl.router_connectivity import RouterConnectivityState
       ```

    2. In WANController.__init__(), add after logger initialization:
       ```python
       self.router_connectivity = RouterConnectivityState(self.logger)
       ```

    3. In WANController.run_cycle(), wrap the apply_rate_changes_if_needed() call:
       - On success: call self.router_connectivity.record_success()
       - On exception: call self.router_connectivity.record_failure(e), log with failure type

    4. Modify the exception handling around apply_rate_changes_if_needed():
       ```python
       try:
           if not self.apply_rate_changes_if_needed(dl_rate, ul_rate):
               # apply_rate_changes_if_needed returns False on router error
               # This is handled internally, but we should record the failure
               self.router_connectivity.record_failure(
                   ConnectionError("Failed to apply rate limits")
               )
               return False
           self.router_connectivity.record_success()
       except Exception as e:
           failure_type = self.router_connectivity.record_failure(e)
           self.logger.warning(
               f"{self.wan_name}: Router communication failed ({failure_type}, "
               f"{self.router_connectivity.consecutive_failures} consecutive)"
           )
           return False
       ```

    5. IMPORTANT: Do NOT reset EWMA or baseline on reconnection. The record_success() method handles logging reconnection; state preservation is architectural invariant.

    Note: Rate-limit logging during sustained outages. Only log every N failures or on transitions:
    - Log on first failure
    - Log when exceeding threshold (e.g., 3 consecutive)
    - Log on recovery
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/test_autorate_error_recovery.py -v -k "router"
    .venv/bin/mypy src/wanctl/autorate_continuous.py
    ```
  </verify>
  <done>WANController.run_cycle() tracks router connectivity, logs failures with type, logs reconnection</done>
</task>

<task type="auto">
  <name>Task 2: Integrate RouterConnectivityState into SteeringDaemon</name>
  <files>src/wanctl/steering/daemon.py</files>
  <action>
    Add RouterConnectivityState to SteeringDaemon:

    1. Add import at top of file:
       ```python
       from wanctl.router_connectivity import RouterConnectivityState
       ```

    2. In SteeringDaemon.__init__(), add after logger initialization:
       ```python
       self.router_connectivity = RouterConnectivityState(self.logger)
       ```

    3. In SteeringDaemon.run_cycle(), track connectivity around router operations:
       - After successful CAKE stats collection: record_success()
       - On router communication failure: record_failure(e) and log with type

    4. Identify router communication points in run_cycle():
       - collect_cake_stats() - reads from router
       - Any mangle rule operations

    5. Wrap these operations:
       ```python
       try:
           cake_drops, queued_packets = self.collect_cake_stats()
           self.router_connectivity.record_success()
       except Exception as e:
           failure_type = self.router_connectivity.record_failure(e)
           self.logger.warning(
               f"Router communication failed ({failure_type}, "
               f"{self.router_connectivity.consecutive_failures} consecutive)"
           )
           # Return False or use fallback values depending on criticality
           return False
       ```

    6. IMPORTANT: Preserve state across reconnection - do NOT reset state machine or EWMA values.
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/integration/test_steering_daemon.py -v -k "connectivity or error"
    .venv/bin/mypy src/wanctl/steering/daemon.py
    ```
  </verify>
  <done>SteeringDaemon.run_cycle() tracks router connectivity, logs failures with type, logs reconnection</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for connectivity tracking in daemons</name>
  <files>tests/test_autorate_error_recovery.py, tests/integration/test_steering_daemon.py</files>
  <action>
    Add tests to verify connectivity tracking integration:

    In tests/test_autorate_error_recovery.py, add:
    1. test_wan_controller_has_router_connectivity_state - verify attribute exists
    2. test_wan_controller_records_success_on_apply_rate - mock successful apply
    3. test_wan_controller_records_failure_on_router_error - mock router failure
    4. test_wan_controller_logs_reconnection_after_failures - verify log message
    5. test_wan_controller_preserves_ewma_across_reconnection - verify no reset

    In tests/integration/test_steering_daemon.py (or new file if better fit), add:
    1. test_steering_daemon_has_router_connectivity_state
    2. test_steering_daemon_records_success_on_cake_stats
    3. test_steering_daemon_records_failure_on_router_error
    4. test_steering_daemon_preserves_state_across_reconnection

    Use unittest.mock to simulate router failures:
    ```python
    with patch.object(controller.router, 'run_cmd', side_effect=ConnectionError("refused")):
        result = controller.run_cycle()
        assert not result
        assert controller.router_connectivity.consecutive_failures == 1
        assert controller.router_connectivity.last_failure_type == "connection_refused"
    ```
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/test_autorate_error_recovery.py tests/integration/test_steering_daemon.py -v --tb=short
    ```
  </verify>
  <done>Tests verify connectivity tracking works in both daemons</done>
</task>

</tasks>

<verification>
```bash
# Run all related tests
.venv/bin/pytest tests/test_autorate_error_recovery.py tests/integration/test_steering_daemon.py -v

# Type check modified files
.venv/bin/mypy src/wanctl/autorate_continuous.py src/wanctl/steering/daemon.py

# Verify no regressions in existing tests
.venv/bin/pytest tests/ -x -q
```
</verification>

<success_criteria>
- WANController has router_connectivity attribute initialized in __init__
- SteeringDaemon has router_connectivity attribute initialized in __init__
- Router failures are recorded with failure type classification
- Reconnection after failures is logged with failure count
- EWMA/baseline state is NOT reset on reconnection
- All existing tests continue to pass
- New tests pass for connectivity tracking
</success_criteria>

<output>
After completion, create `.planning/phases/43-error-detection-reconnection/43-02-SUMMARY.md`
</output>
