---
phase: 43-error-detection-reconnection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/wanctl/router_connectivity.py
  - tests/test_router_connectivity.py
autonomous: true

must_haves:
  truths:
    - "RouterConnectivityState tracks consecutive failures accurately"
    - "classify_failure_type() distinguishes timeout, connection_refused, dns_failure, auth_failure, network_unreachable"
    - "record_success() resets failure counters and logs reconnection"
    - "record_failure() increments counters and classifies failure type"
  artifacts:
    - path: "src/wanctl/router_connectivity.py"
      provides: "RouterConnectivityState class and classify_failure_type function"
      exports: ["RouterConnectivityState", "classify_failure_type"]
      min_lines: 80
    - path: "tests/test_router_connectivity.py"
      provides: "Unit tests for connectivity tracking"
      min_lines: 150
  key_links:
    - from: "src/wanctl/router_connectivity.py"
      to: "retry_utils.is_retryable_error"
      via: "Pattern extension"
      pattern: "isinstance.*Exception"
---

<objective>
Create RouterConnectivityState class and classify_failure_type() function for cycle-level router connectivity tracking.

Purpose: Provides the foundation for detecting router unreachability mid-cycle and tracking reconnection state. Extends existing is_retryable_error() pattern to classify failure types for appropriate handling.

Output: New router_connectivity.py module with full test coverage via TDD.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/43-error-detection-reconnection/43-RESEARCH.md

@src/wanctl/retry_utils.py (is_retryable_error pattern)
@src/wanctl/router_client.py (FailoverRouterClient pattern)
</context>

<feature>
  <name>RouterConnectivityState and classify_failure_type</name>
  <files>src/wanctl/router_connectivity.py, tests/test_router_connectivity.py</files>
  <behavior>
    classify_failure_type(exception) returns failure type string:
    - TimeoutError, socket.timeout, subprocess.TimeoutExpired -> "timeout"
    - ConnectionRefusedError, "connection refused" -> "connection_refused"
    - "network is unreachable", "no route to host" -> "network_unreachable"
    - socket.gaierror, "name or service not known" -> "dns_failure"
    - AuthenticationException, "authentication failed" -> "auth_failure"
    - requests.exceptions.ConnectTimeout, ReadTimeout -> "timeout"
    - requests.exceptions.ConnectionError with "refused" -> "connection_refused"
    - Other -> "unknown"

    RouterConnectivityState class:
    - __init__(logger) initializes: consecutive_failures=0, last_failure_type=None, last_failure_time=None, is_reachable=True
    - record_success() resets counters, logs if recovering from failures, sets is_reachable=True
    - record_failure(exception) increments consecutive_failures, sets last_failure_type via classify_failure_type, sets last_failure_time, sets is_reachable=False, returns failure_type
    - to_dict() returns state as dict for health endpoint integration
  </behavior>
  <implementation>
    Follow TDD: write failing tests first, then implement.

    Test cases for classify_failure_type:
    - test_timeout_error -> "timeout"
    - test_socket_timeout -> "timeout"
    - test_subprocess_timeout -> "timeout"
    - test_connection_refused_error -> "connection_refused"
    - test_connection_refused_string -> "connection_refused"
    - test_network_unreachable -> "network_unreachable"
    - test_no_route_to_host -> "network_unreachable"
    - test_socket_gaierror -> "dns_failure"
    - test_dns_string -> "dns_failure"
    - test_auth_failure -> "auth_failure"
    - test_requests_connect_timeout -> "timeout"
    - test_requests_read_timeout -> "timeout"
    - test_requests_connection_error_refused -> "connection_refused"
    - test_requests_connection_error_other -> "network_unreachable"
    - test_unknown_exception -> "unknown"

    Test cases for RouterConnectivityState:
    - test_initial_state_is_reachable
    - test_record_success_no_prior_failures
    - test_record_failure_increments_counter
    - test_record_failure_sets_type
    - test_record_failure_sets_unreachable
    - test_record_success_after_failures_logs_reconnect
    - test_record_success_resets_counters
    - test_consecutive_failures_accumulate
    - test_to_dict_returns_state

    Implementation notes:
    - Import time for monotonic timestamps
    - Use logging.Logger type hint
    - Match is_retryable_error() pattern from retry_utils.py
    - Handle requests exceptions with try/except ImportError
    - Handle paramiko exceptions with try/except ImportError
  </implementation>
</feature>

<verification>
```bash
# Run tests for new module
.venv/bin/pytest tests/test_router_connectivity.py -v

# Verify type hints
.venv/bin/mypy src/wanctl/router_connectivity.py

# Verify code style
.venv/bin/ruff check src/wanctl/router_connectivity.py tests/test_router_connectivity.py
```
</verification>

<success_criteria>
- All tests in test_router_connectivity.py pass
- classify_failure_type correctly classifies all exception types
- RouterConnectivityState tracks consecutive failures and reachability
- mypy and ruff pass with no errors
- Code follows existing codebase patterns (retry_utils.py style)
</success_criteria>

<output>
After completion, create `.planning/phases/43-error-detection-reconnection/43-01-SUMMARY.md`
</output>
