---
phase: 43-error-detection-reconnection
plan: 03
type: execute
wave: 3
depends_on: ["43-02"]
files_modified:
  - src/wanctl/health_check.py
  - src/wanctl/steering/health.py
  - tests/test_health_check.py
  - tests/test_steering_health.py
autonomous: true

must_haves:
  truths:
    - "Health endpoint includes router_connectivity section"
    - "Connectivity state shows reachable, consecutive_failures, last_failure_type"
    - "Health status degrades to 'degraded' when router unreachable for extended period"
    - "Autorate and steering health endpoints both report connectivity"
  artifacts:
    - path: "src/wanctl/health_check.py"
      provides: "Health endpoint with router connectivity"
      contains: "router_connectivity"
    - path: "src/wanctl/steering/health.py"
      provides: "Steering health endpoint with router connectivity"
      contains: "router_connectivity"
  key_links:
    - from: "src/wanctl/health_check.py"
      to: "WANController.router_connectivity"
      via: "State access in _get_health_status"
      pattern: "router_connectivity"
    - from: "src/wanctl/steering/health.py"
      to: "SteeringDaemon.router_connectivity"
      via: "State access in health response"
      pattern: "router_connectivity"
---

<objective>
Update health endpoints to report router connectivity state for monitoring and alerting.

Purpose: External monitoring systems need visibility into router connectivity for operational awareness. The health endpoint should indicate when the controller is unable to communicate with the router.

Output: Enhanced health endpoints with router_connectivity section in both autorate and steering daemons.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/43-error-detection-reconnection/43-RESEARCH.md
@.planning/phases/43-error-detection-reconnection/43-01-SUMMARY.md
@.planning/phases/43-error-detection-reconnection/43-02-SUMMARY.md

@src/wanctl/health_check.py (autorate health endpoint)
@src/wanctl/steering/health.py (steering health endpoint)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update autorate health endpoint with router connectivity</name>
  <files>src/wanctl/health_check.py</files>
  <action>
    Enhance _get_health_status() in HealthCheckHandler:

    1. Add router_connectivity section to each WAN's health info:
       ```python
       wan_health: dict[str, Any] = {
           "name": config.wan_name,
           "baseline_rtt_ms": round(wan_controller.baseline_rtt, 2),
           # ... existing fields ...
           "router_connectivity": wan_controller.router_connectivity.to_dict(),
       }
       ```

    2. Include overall router connectivity in top-level health:
       ```python
       # Aggregate connectivity across all WANs
       all_reachable = all(
           wan_info["controller"].router_connectivity.is_reachable
           for wan_info in self.controller.wan_controllers
       )
       health["router_reachable"] = all_reachable
       ```

    3. Factor router reachability into health status determination:
       ```python
       # Current logic: consecutive_failures >= 3 means degraded
       # Add: router unreachable also means degraded
       is_healthy = (
           self.consecutive_failures < 3
           and all_reachable
       )
       ```

    4. If controller is None (startup), return sensible defaults:
       ```python
       if not self.controller:
           health["router_reachable"] = True  # Assume OK during startup
           return health
       ```

    Note: Keep the existing consecutive_failures logic for cycle failures. Router connectivity is a separate signal that should also degrade health.
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/test_health_check.py -v -k "router"
    .venv/bin/mypy src/wanctl/health_check.py
    ```
  </verify>
  <done>Health endpoint reports router_connectivity per-WAN and aggregated router_reachable status</done>
</task>

<task type="auto">
  <name>Task 2: Update steering health endpoint with router connectivity</name>
  <files>src/wanctl/steering/health.py</files>
  <action>
    Check if steering has its own health endpoint. Based on research, steering uses a similar pattern.

    If src/wanctl/steering/health.py exists:
    1. Add router_connectivity to the health response:
       ```python
       health = {
           "status": "healthy" if is_healthy else "degraded",
           # ... existing fields ...
           "router_connectivity": daemon.router_connectivity.to_dict(),
       }
       ```

    2. Factor router reachability into health determination:
       ```python
       is_healthy = (
           existing_health_condition
           and daemon.router_connectivity.is_reachable
       )
       ```

    If steering uses a different health pattern (e.g., shared with autorate), update that shared location.

    Note: Steering daemon communicates with router for CAKE stats and mangle rules. Connectivity failures here should also be visible in health.
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/test_steering_health.py -v -k "router or connectivity" 2>/dev/null || echo "No steering health tests yet"
    .venv/bin/mypy src/wanctl/steering/health.py 2>/dev/null || echo "No steering health module"
    ```
  </verify>
  <done>Steering health endpoint reports router connectivity state</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for health endpoint connectivity reporting</name>
  <files>tests/test_health_check.py, tests/test_steering_health.py</files>
  <action>
    Add tests to verify connectivity reporting in health endpoints:

    In tests/test_health_check.py:
    1. test_health_includes_router_connectivity_per_wan
       - Mock controller with router_connectivity.to_dict() returning state
       - Verify response JSON includes router_connectivity section

    2. test_health_includes_router_reachable_aggregate
       - Verify top-level router_reachable field exists

    3. test_health_degrades_when_router_unreachable
       - Set router_connectivity.is_reachable = False
       - Verify status is "degraded" (HTTP 503)

    4. test_health_healthy_when_router_reachable
       - Set router_connectivity.is_reachable = True
       - Verify status is "healthy" (HTTP 200)

    Example test:
    ```python
    def test_health_includes_router_connectivity(mock_controller):
        # Setup mock
        wan = mock_controller.wan_controllers[0]["controller"]
        wan.router_connectivity.is_reachable = True
        wan.router_connectivity.consecutive_failures = 0

        # Make request
        response = client.get("/health")

        # Verify
        assert response.status_code == 200
        data = response.json()
        assert "router_reachable" in data
        assert data["router_reachable"] is True
        assert "router_connectivity" in data["wans"][0]
    ```

    For steering health (if applicable):
    1. test_steering_health_includes_router_connectivity
    2. test_steering_health_degrades_when_router_unreachable
  </action>
  <verify>
    ```bash
    .venv/bin/pytest tests/test_health_check.py tests/test_steering_health.py -v
    ```
  </verify>
  <done>Tests verify health endpoints correctly report and react to router connectivity</done>
</task>

</tasks>

<verification>
```bash
# Run health check tests
.venv/bin/pytest tests/test_health_check.py -v

# Test health endpoint manually (if daemon running)
# curl -s http://127.0.0.1:9101/health | python3 -m json.tool

# Type check
.venv/bin/mypy src/wanctl/health_check.py

# Full test suite to verify no regressions
.venv/bin/pytest tests/ -x -q
```
</verification>

<success_criteria>
- Health endpoint response includes router_connectivity per WAN
- Health endpoint includes top-level router_reachable boolean
- Health status degrades (503) when router is unreachable
- Health status remains healthy (200) when router is reachable
- Steering health endpoint (if exists) also reports connectivity
- All existing health tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-error-detection-reconnection/43-03-SUMMARY.md`
</output>
