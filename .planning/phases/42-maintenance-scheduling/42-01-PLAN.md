---
phase: 42-maintenance-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wanctl/storage/maintenance.py
  - src/wanctl/storage/__init__.py
  - src/wanctl/autorate_continuous.py
  - src/wanctl/steering/daemon.py
  - tests/test_storage_maintenance.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Daemon startup runs cleanup_old_metrics() if storage enabled"
    - "Daemon startup runs downsample_metrics() if storage enabled"
    - "Maintenance runs before main control loop starts"
    - "Maintenance only runs when db_path is configured"
    - "Maintenance errors are logged but do not prevent daemon startup"
  artifacts:
    - path: "src/wanctl/storage/maintenance.py"
      provides: "run_startup_maintenance() helper function"
      exports: ["run_startup_maintenance"]
    - path: "tests/test_storage_maintenance.py"
      provides: "Integration tests for maintenance at startup"
      min_lines: 50
  key_links:
    - from: "src/wanctl/autorate_continuous.py"
      to: "wanctl.storage.run_startup_maintenance"
      via: "import and call after record_config_snapshot"
      pattern: "run_startup_maintenance"
    - from: "src/wanctl/steering/daemon.py"
      to: "wanctl.storage.run_startup_maintenance"
      via: "import and call after record_config_snapshot"
      pattern: "run_startup_maintenance"
---

<objective>
Wire cleanup and downsampling functions to daemon startup for automatic maintenance.

Purpose: Close tech debt - cleanup_old_metrics() and downsample_metrics() exist but are never called.
Without this, the database grows unbounded and long-range queries return empty results.

Output: Both daemons run maintenance on startup; database stays bounded; downsampled data available for queries.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing storage functions
@src/wanctl/storage/retention.py
@src/wanctl/storage/downsampler.py
@src/wanctl/storage/__init__.py

# Daemon startup patterns (where maintenance will be wired)
@src/wanctl/autorate_continuous.py (lines 1729-1738 for startup pattern)
@src/wanctl/steering/daemon.py (lines 1418-1425 for startup pattern)

# Existing test patterns
@tests/test_storage_retention.py
@tests/test_storage_downsampler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create maintenance helper module</name>
  <files>src/wanctl/storage/maintenance.py, src/wanctl/storage/__init__.py</files>
  <action>
Create `src/wanctl/storage/maintenance.py` with `run_startup_maintenance()` function:

```python
def run_startup_maintenance(
    conn: sqlite3.Connection,
    retention_days: int = DEFAULT_RETENTION_DAYS,
    logger: logging.Logger | None = None,
) -> dict[str, Any]:
    """Run all maintenance tasks at daemon startup.

    Executes cleanup and downsampling in a single call.
    Errors are logged but not raised (daemon should start regardless).

    Args:
        conn: SQLite connection (from MetricsWriter.connection)
        retention_days: Retention period for cleanup
        logger: Optional logger (uses module logger if None)

    Returns:
        Dict with maintenance results:
        - cleanup_deleted: int (rows deleted by cleanup)
        - downsampling: dict[str, int] (rows created per level)
        - vacuumed: bool (whether VACUUM ran)
        - error: str | None (error message if any)
    """
```

Implementation:
1. Call `cleanup_old_metrics(conn, retention_days)` - get deleted count
2. Call `vacuum_if_needed(conn, deleted_count)` - get vacuum result
3. Call `downsample_metrics(conn)` - get downsampling results
4. Wrap all in try/except - log errors but return error in result dict
5. Log summary at INFO level if any work done

Update `src/wanctl/storage/__init__.py`:
- Import `run_startup_maintenance` from maintenance.py
- Add to `__all__` list
  </action>
  <verify>
`python -c "from wanctl.storage import run_startup_maintenance; print('OK')"`
  </verify>
  <done>
run_startup_maintenance() exported from wanctl.storage and calls cleanup + downsample + vacuum
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire maintenance to autorate daemon startup</name>
  <files>src/wanctl/autorate_continuous.py</files>
  <action>
In the `main()` function, after the existing `record_config_snapshot()` call (around line 1738):

1. Add import for `run_startup_maintenance` (in the same conditional import block)
2. Call maintenance right after config snapshot:

```python
if db_path and isinstance(db_path, str):
    from wanctl.storage import MetricsWriter, record_config_snapshot, run_startup_maintenance

    writer = MetricsWriter(Path(db_path))
    record_config_snapshot(writer, first_config.wan_name, first_config.data, "startup")

    # Run startup maintenance (cleanup + downsampling)
    maint_result = run_startup_maintenance(
        writer.connection,
        retention_days=storage_config.get("retention_days", 7),
        logger=controller.wan_controllers[0]["logger"],
    )
    if maint_result.get("error"):
        controller.wan_controllers[0]["logger"].warning(
            f"Startup maintenance error: {maint_result['error']}"
        )
```

Key points:
- Use the existing `writer.connection` for the DB connection
- Use first WAN's logger for logging
- Get retention_days from storage_config
- Log warning if error (but don't fail startup)
  </action>
  <verify>
`ruff check src/wanctl/autorate_continuous.py` - no errors
`grep -n "run_startup_maintenance" src/wanctl/autorate_continuous.py` - shows import and call
  </verify>
  <done>
Autorate daemon calls run_startup_maintenance() after record_config_snapshot() when storage enabled
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire maintenance to steering daemon startup and add tests</name>
  <files>src/wanctl/steering/daemon.py, tests/test_storage_maintenance.py</files>
  <action>
**Part A: Wire to steering daemon**

In `main()` function of steering/daemon.py, after `record_config_snapshot()` call (around line 1424):

```python
if storage_config.get("db_path"):
    from wanctl.storage import record_config_snapshot, run_startup_maintenance

    writer = MetricsWriter(Path(storage_config["db_path"]))
    record_config_snapshot(writer, config.primary_wan, config.data, "startup")

    # Run startup maintenance (cleanup + downsampling)
    maint_result = run_startup_maintenance(
        writer.connection,
        retention_days=storage_config.get("retention_days", 7),
        logger=logger,
    )
    if maint_result.get("error"):
        logger.warning(f"Startup maintenance error: {maint_result['error']}")

    logger.info(f"Config snapshot recorded to {storage_config['db_path']}")
```

**Part B: Create tests**

Create `tests/test_storage_maintenance.py` with tests:

1. `test_run_startup_maintenance_calls_cleanup` - verify cleanup_old_metrics called
2. `test_run_startup_maintenance_calls_downsample` - verify downsample_metrics called
3. `test_run_startup_maintenance_calls_vacuum_when_needed` - verify vacuum called if many deletions
4. `test_run_startup_maintenance_returns_results` - verify return dict structure
5. `test_run_startup_maintenance_handles_errors` - verify errors logged, not raised
6. `test_run_startup_maintenance_with_logger` - verify logging works
7. `test_run_startup_maintenance_without_logger` - verify default logger works

Use existing patterns from test_storage_retention.py and test_storage_downsampler.py:
- Use tmp_path fixture for test database
- Use create_tables() for schema setup
- Insert old test data, run maintenance, verify cleanup/downsampling happened
  </action>
  <verify>
`ruff check src/wanctl/steering/daemon.py tests/test_storage_maintenance.py`
`.venv/bin/pytest tests/test_storage_maintenance.py -v` - all tests pass
`grep -n "run_startup_maintenance" src/wanctl/steering/daemon.py` - shows import and call
  </verify>
  <done>
Steering daemon calls run_startup_maintenance(); new test file covers maintenance function
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
   `.venv/bin/pytest tests/test_storage*.py -v`

2. Verify exports:
   `python -c "from wanctl.storage import run_startup_maintenance, cleanup_old_metrics, downsample_metrics; print('All exports OK')"`

3. Verify wiring in both daemons:
   `grep -l "run_startup_maintenance" src/wanctl/autorate_continuous.py src/wanctl/steering/daemon.py`
   (should show both files)

4. Run type checks:
   `.venv/bin/mypy src/wanctl/storage/maintenance.py`
</verification>

<success_criteria>
- [ ] `run_startup_maintenance()` function exists in storage module
- [ ] Function calls cleanup_old_metrics(), vacuum_if_needed(), downsample_metrics()
- [ ] Function handles errors gracefully (logs, doesn't raise)
- [ ] Autorate daemon calls maintenance at startup (when storage enabled)
- [ ] Steering daemon calls maintenance at startup (when storage enabled)
- [ ] All new tests pass
- [ ] Type checks pass
- [ ] Ruff linting passes
</success_criteria>

<output>
After completion, create `.planning/phases/42-maintenance-scheduling/42-01-SUMMARY.md`
</output>
