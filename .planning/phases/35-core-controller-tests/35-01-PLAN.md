---
phase: 35-core-controller-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_autorate_entry_points.py
  - tests/test_autorate_config.py
autonomous: true

must_haves:
  truths:
    - "main() validate-config mode tested (success, invalid, multiple files)"
    - "main() oneshot mode tested (single cycle, debug flag)"
    - "main() daemon mode startup tested (lock, signals, servers)"
    - "Daemon shutdown sequence tested (state save, lock release, server stop)"
    - "Signal handler integration tested (SIGTERM, SIGINT)"
    - "Config._load_download_config tested (legacy and state-based floors)"
    - "Config._load_upload_config tested (legacy and state-based floors)"
  artifacts:
    - path: "tests/test_autorate_entry_points.py"
      provides: "Main entry point and signal handler tests"
      min_lines: 250
    - path: "tests/test_autorate_config.py"
      provides: "Config class loading and validation tests"
      min_lines: 100
  key_links:
    - from: "tests/test_autorate_entry_points.py"
      to: "src/wanctl/autorate_continuous.py"
      via: "import and test main() function"
      pattern: "from wanctl.autorate_continuous import"
    - from: "tests/test_autorate_entry_points.py"
      to: "src/wanctl/signal_utils.py"
      via: "test signal handler integration"
      pattern: "from wanctl.signal_utils import"
    - from: "tests/test_autorate_config.py"
      to: "src/wanctl/autorate_continuous.py"
      via: "test Config class loading methods"
      pattern: "from wanctl.autorate_continuous import Config"
---

<objective>
Test main() entry points (daemon mode, oneshot mode, validate-config mode), signal handler integration, and Config class loading/validation methods.

Purpose: Coverage target lines 1511-1808 (main() function), lines 274-343 (Config._load_download_config, _load_upload_config), and signal integration paths. Critical for ensuring graceful startup/shutdown and proper config validation.

Output: Comprehensive test files covering all main() execution modes, signal handling, and Config loading methods.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-core-controller-tests/35-CONTEXT.md

@src/wanctl/autorate_continuous.py
@src/wanctl/signal_utils.py
@tests/test_signal_utils.py
@tests/test_wan_controller.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test file with imports and fixtures</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Create test file with required imports and shared fixtures:

**Imports:**
- pytest, MagicMock, patch from unittest.mock
- argparse for simulating CLI
- tmp_path fixture for config files
- signal module for signal constants

**Fixtures:**
- valid_config_yaml: Minimal valid YAML config string (use 30+ fields pattern from test_wan_controller.py)
- invalid_config_yaml: YAML with missing required fields
- mock_controller: Mock ContinuousAutoRate that returns successfully
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_entry_points.py --collect-only
  </verify>
  <done>
- tests/test_autorate_entry_points.py exists with imports and fixtures
- pytest can collect the module
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TestValidateConfigMode and TestOneshotMode classes</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add TestValidateConfigMode class with tests:

- test_validate_config_success: Valid config prints success, returns 0
- test_validate_config_invalid: Invalid config prints error, returns 1
- test_validate_config_multiple_files: Both valid = 0, any invalid = 1
- test_validate_config_prints_wan_details: Output includes WAN name, transport, floors

Add TestOneshotMode class with tests:

- test_oneshot_runs_single_cycle: Calls run_cycle(use_lock=True) exactly once
- test_oneshot_returns_none: Returns None on success
- test_oneshot_with_debug_flag: Debug flag passed to controller

Use capsys fixture for stdout, patch sys.argv and ContinuousAutoRate.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_entry_points.py::TestValidateConfigMode tests/test_autorate_entry_points.py::TestOneshotMode -v
  </verify>
  <done>
- TestValidateConfigMode has 4 passing tests
- TestOneshotMode has 3 passing tests
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement TestDaemonModeStartup and TestDaemonModeShutdown classes</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add TestDaemonModeStartup class with tests:

- test_daemon_acquires_lock_on_startup: validate_and_acquire_lock called for each WAN
- test_daemon_refuses_start_when_locked: Another instance running returns 1
- test_daemon_registers_signal_handlers: register_signal_handlers called
- test_daemon_starts_metrics_server_when_enabled: metrics_enabled=True starts server
- test_daemon_starts_health_server_when_enabled: health_check_enabled=True starts server

Add TestDaemonModeShutdown class with tests:

- test_shutdown_on_sigterm: Signal handler sets shutdown_event, loop exits
- test_shutdown_saves_state: save_state(force=True) called for all WANs in finally
- test_shutdown_releases_locks: lock_path.unlink called for each lock
- test_shutdown_closes_router_connections: router.ssh.close() called
- test_shutdown_stops_servers: metrics_server.stop() and health_server.shutdown() called

Use patch context managers to mock lock_utils, register_signal_handlers, start_metrics_server, start_health_server.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_entry_points.py::TestDaemonModeStartup tests/test_autorate_entry_points.py::TestDaemonModeShutdown -v
  </verify>
  <done>
- TestDaemonModeStartup has 5 passing tests
- TestDaemonModeShutdown has 5 passing tests
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement TestDaemonControlLoop and TestSignalIntegration classes</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add TestDaemonControlLoop class with tests:

- test_control_loop_runs_cycles_until_shutdown: run_cycle called repeatedly until shutdown_event set
- test_control_loop_tracks_consecutive_failures: Failure increments counter, success resets
- test_control_loop_notifies_watchdog_on_success: notify_watchdog called when healthy
- test_control_loop_notifies_degraded_on_failures: MAX_CONSECUTIVE_FAILURES triggers notify_degraded
- test_control_loop_sleeps_remainder_of_interval: time.sleep called with positive remainder

Use threading to set shutdown_event after N cycles to prevent infinite loop.

Add TestSignalIntegration class with tests:

- test_sigterm_triggers_graceful_shutdown: SIGTERM sets event, loop exits cleanly
- test_sigint_triggers_graceful_shutdown: SIGINT (Ctrl+C) same behavior
- test_shutdown_event_checked_each_iteration: is_shutdown_requested called in loop

Use setup_method/teardown_method with reset_shutdown_state() for isolation.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_entry_points.py::TestDaemonControlLoop tests/test_autorate_entry_points.py::TestSignalIntegration -v
  </verify>
  <done>
- TestDaemonControlLoop has 5 passing tests
- TestSignalIntegration has 3 passing tests
- Control loop and signal integration verified
  </done>
</task>

<task type="auto">
  <name>Task 5: Create test_autorate_config.py with Config loading tests</name>
  <files>tests/test_autorate_config.py</files>
  <action>
Create new test file for Config class loading/validation:

**Imports:**
- pytest, tmp_path fixture
- Config from wanctl.autorate_continuous

**Fixtures:**
- base_config_dict: Dict with all required fields

Add TestLoadDownloadConfig class:

- test_load_download_legacy_floor: Single floor_mbps applied to all states
- test_load_download_state_based_floors: floor_green_mbps, floor_yellow_mbps, floor_red_mbps mapped correctly
- test_load_download_soft_red_defaults_to_yellow: Missing floor_soft_red_mbps uses floor_yellow_mbps
- test_load_download_floor_ordering_validation: Invalid ordering raises ValueError

Add TestLoadUploadConfig class:

- test_load_upload_legacy_floor: Single floor_mbps applied to all states
- test_load_upload_state_based_floors: floor_green_mbps, floor_yellow_mbps, floor_red_mbps mapped correctly
- test_load_upload_floor_ordering_validation: Invalid ordering raises ValueError

Cover lines 274-343 (_load_download_config, _load_upload_config).
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_config.py -v
  </verify>
  <done>
- tests/test_autorate_config.py created with 7+ tests
- Config._load_download_config covered (legacy and state-based)
- Config._load_upload_config covered (legacy and state-based)
- Floor ordering validation tested
  </done>
</task>

</tasks>

<verification>
```bash
# Run all entry point tests
.venv/bin/pytest tests/test_autorate_entry_points.py -v

# Run Config loading tests
.venv/bin/pytest tests/test_autorate_config.py -v

# Verify coverage improvement for lines 274-343 and 1511-1808
.venv/bin/pytest tests/test_autorate_entry_points.py tests/test_autorate_config.py --cov=wanctl.autorate_continuous --cov-report=term-missing | grep -A50 "autorate_continuous"
```
</verification>

<success_criteria>
- [ ] tests/test_autorate_entry_points.py created with 25+ test methods
- [ ] tests/test_autorate_config.py created with 7+ test methods
- [ ] All main() modes tested (validate-config, oneshot, daemon)
- [ ] Signal handler integration tested (SIGTERM, SIGINT)
- [ ] Startup sequence tested (lock acquisition, server startup)
- [ ] Shutdown sequence tested (state save, lock release, server shutdown)
- [ ] Config._load_download_config tested (legacy and state-based floors)
- [ ] Config._load_upload_config tested (legacy and state-based floors)
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-core-controller-tests/35-01-SUMMARY.md`
</output>
