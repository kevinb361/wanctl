---
phase: 35-core-controller-tests
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_autorate_entry_points.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "ContinuousAutoRate.__init__ logging paths tested"
    - "ContinuousAutoRate.run_cycle with lock acquisition tested"
    - "main() daemon RuntimeError and OSError handlers tested"
    - "main() finally block exception handlers tested"
    - "__main__ entry point covered"
  artifacts:
    - path: "tests/test_autorate_entry_points.py"
      provides: "ContinuousAutoRate and main() daemon coverage"
      contains: "ContinuousAutoRate|daemon.*error|finally.*cleanup"
  key_links:
    - from: "tests/test_autorate_entry_points.py"
      to: "autorate_continuous.main"
      via: "daemon mode error handling"
      pattern: "run_daemon|RuntimeError|OSError"
---

<objective>
Cover ContinuousAutoRate initialization, run_cycle with locks, and main() daemon error handlers.

Purpose: Close coverage gaps in lines 1399-1459, 1474-1503, 1635-1651, 1676-1692, 1700, 1758-1802, 1812
Output: Extended tests in test_autorate_entry_points.py (~54 lines covered)
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/35-core-controller-tests/35-VERIFICATION.md

# Source code for uncovered lines
@src/wanctl/autorate_continuous.py (lines 1395-1503: ContinuousAutoRate class, lines 1625-1700: daemon setup, lines 1751-1812: cleanup and entry)
</context>

<tasks>

<task type="auto">
  <name>Task 1: ContinuousAutoRate.__init__ logging coverage</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add tests for ContinuousAutoRate.__init__ that exercise all logging paths:

1. Test __init__ logs all config parameters:
   - Create valid config with all floor values, thresholds, EWMA params
   - Instantiate ContinuousAutoRate([config_path], debug=True)
   - Mock logger and verify all logger.info calls made:
     - "=== Continuous CAKE Controller"
     - "Download: GREEN=...M"
     - "Upload: GREEN=...M"
     - "Download Thresholds:"
     - "Upload Thresholds:"
     - "EWMA: baseline_alpha=..., load_alpha=..."
     - "Ping: hosts=..."
   - Covers lines 1399-1444

2. Test __init__ creates WANController and adds to list:
   - Verify len(controller.wan_controllers) == 1
   - Verify wan_controllers[0] has "controller", "config", "logger" keys
   - Covers lines 1446-1461

Mock RouterOS and RTTMeasurement to avoid real connections.
Use full valid config from test fixtures.
  </action>
  <verify>pytest tests/test_autorate_entry_points.py -v -k "init_logging" passes</verify>
  <done>Lines 1399-1459 covered by __init__ logging tests</done>
</task>

<task type="auto">
  <name>Task 2: ContinuousAutoRate.run_cycle with lock tests</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add tests for ContinuousAutoRate.run_cycle() with lock acquisition:

1. Test run_cycle with use_lock=True:
   - Mock LockFile context manager
   - Mock WANController.run_cycle -> True
   - Call controller.run_cycle(use_lock=True)
   - Verify LockFile entered and exited
   - Verify returns True
   - Covers lines 1482-1485

2. Test run_cycle with use_lock=False:
   - Mock WANController.run_cycle -> True
   - Call controller.run_cycle(use_lock=False)
   - Verify LockFile NOT used
   - Covers lines 1486-1489

3. Test run_cycle LockAcquisitionError handling:
   - Mock LockFile.__enter__ to raise LockAcquisitionError(Path, 10.0)
   - Verify returns False
   - Verify logger.debug "Skipping cycle"
   - Covers lines 1490-1493

4. Test run_cycle generic Exception handling:
   - Mock WANController.run_cycle to raise Exception("test error")
   - Verify returns False
   - Verify logger.error "Cycle error"
   - Covers lines 1494-1497

5. Test get_lock_paths():
   - Call controller.get_lock_paths()
   - Verify returns list of Path objects
   - Covers line 1503

Create TestContinuousAutoRateRunCycle class.
  </action>
  <verify>pytest tests/test_autorate_entry_points.py -v -k "run_cycle" passes</verify>
  <done>Lines 1474-1503 covered by run_cycle tests</done>
</task>

<task type="auto">
  <name>Task 3: main() daemon RuntimeError and OSError handlers</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add tests for main() daemon error handlers:

1. Test RuntimeError during lock validation:
   - Mock validate_and_acquire_lock to raise RuntimeError("test error")
   - Call main() with daemon mode args
   - Verify returns 1
   - Verify logger.error "Failed to validate lock"
   - Covers lines 1635-1639

2. Test emergency_lock_cleanup function:
   - This is tested indirectly - verify atexit.register called
   - Covers lines 1647-1651

3. Test OSError when starting metrics server:
   - Mock start_metrics_server to raise OSError("port in use")
   - Call main() with daemon mode and metrics_enabled=True
   - Verify logger.warning "Failed to start metrics server"
   - Verify daemon continues (doesn't exit)
   - Covers lines 1676-1679

4. Test OSError when starting health server:
   - Mock start_health_server to raise OSError("port in use")
   - Call main() with daemon mode and health_check_enabled=True
   - Verify logger.warning "Failed to start health check server"
   - Verify daemon continues
   - Covers lines 1689-1692

5. Test is_systemd_available branch:
   - Mock is_systemd_available to return True
   - Verify logger.info "Systemd watchdog support enabled"
   - Covers line 1700

Create TestDaemonErrorHandlers class.
  </action>
  <verify>pytest tests/test_autorate_entry_points.py -v -k "daemon_error" passes</verify>
  <done>Lines 1635-1700 covered by daemon error handler tests</done>
</task>

<task type="auto">
  <name>Task 4: main() finally block exception handlers</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add tests for main() finally block exception handlers:

1. Test save_state exception in finally (caught, continues):
   - Mock wan_controller.save_state to raise Exception
   - Force daemon shutdown (mock is_shutdown_requested -> True)
   - Verify exception caught (pass nosec)
   - Verify cleanup continues
   - Covers lines 1758-1759

2. Test atexit.unregister exception (caught):
   - Mock atexit.unregister to raise Exception
   - Verify exception caught
   - Covers lines 1773-1774

3. Test router close exception (caught, logged):
   - Mock router.close to raise Exception
   - Verify logger.debug "Error closing router connection"
   - Covers lines 1785-1786

4. Test metrics_server.stop exception (caught, logged):
   - Mock metrics_server.stop to raise Exception
   - Verify logger.debug "Error shutting down metrics server"
   - Covers lines 1792-1794

5. Test health_server.shutdown exception (caught, logged):
   - Mock health_server.shutdown to raise Exception
   - Verify logger.debug "Error shutting down health server"
   - Covers lines 1800-1802

Create TestDaemonCleanupHandlers class.
  </action>
  <verify>pytest tests/test_autorate_entry_points.py -v -k "cleanup" passes</verify>
  <done>Lines 1758-1802 covered by cleanup exception tests</done>
</task>

<task type="auto">
  <name>Task 5: __main__ entry point coverage</name>
  <files>tests/test_autorate_entry_points.py</files>
  <action>
Add test for __main__ entry point:

1. Test __name__ == "__main__" block:
   - Import autorate_continuous module
   - Verify the module has the if __name__ == "__main__" block
   - Use runpy.run_module or subprocess to execute module as script
   - Mock main() to return 0
   - Verify sys.exit called with main() return value
   - Covers line 1812

Alternative approach: Use importlib to test the entry point directly:
   - from unittest.mock import patch
   - with patch('wanctl.autorate_continuous.main', return_value=0):
   -     with patch('sys.exit') as mock_exit:
   -         runpy.run_module('wanctl.autorate_continuous', run_name='__main__')
   -         mock_exit.assert_called_once_with(0)

Note: This line is often excluded from coverage using # pragma: no cover, but for 90% target we should test it.
  </action>
  <verify>pytest tests/test_autorate_entry_points.py -v -k "main_entry" passes</verify>
  <done>Line 1812 covered by __main__ entry point test</done>
</task>

</tasks>

<verification>
```bash
# Run all new tests
pytest tests/test_autorate_entry_points.py -v -k "init_logging or run_cycle or daemon_error or cleanup or main_entry"

# Verify coverage improvement
pytest tests/ --cov=wanctl.autorate_continuous --cov-report=term-missing -q 2>&1 | grep "autorate_continuous"
# Expect: lines 1399-1503, 1635-1700, 1758-1802, 1812 no longer in missing list
```
</verification>

<success_criteria>
- Lines 1399-1459 (ContinuousAutoRate.__init__ logging) covered
- Lines 1474-1503 (run_cycle, get_lock_paths) covered
- Lines 1635-1651 (RuntimeError handler, emergency_lock_cleanup) covered
- Lines 1676-1692 (metrics/health OSError handlers) covered
- Line 1700 (is_systemd_available branch) covered
- Lines 1758-1802 (finally block exception handlers) covered
- Line 1812 (__main__ entry point) covered
- All tests pass with `pytest -v`
- Coverage reaches 90%+ target
</success_criteria>

<output>
After completion, create `.planning/phases/35-core-controller-tests/35-06-SUMMARY.md`
</output>
