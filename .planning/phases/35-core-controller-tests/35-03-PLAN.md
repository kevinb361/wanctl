---
phase: 35-core-controller-tests
plan: 03
type: execute
wave: 2
depends_on: ["35-01", "35-02"]
files_modified:
  - tests/test_autorate_error_recovery.py
  - tests/test_wan_controller.py
autonomous: true

must_haves:
  truths:
    - "RouterOS initialization tested (__init__, get_router_client_with_failover)"
    - "Router failure recovery tested (set_limits returns False)"
    - "Measurement failure fallback tested (freeze, use_last_rtt, graceful_degradation)"
    - "TCP RTT fallback and ICMP recovery tested (v1.1.0 ICMP blackout fix)"
    - "Total connectivity loss tested (both ICMP and TCP fail)"
    - "run_cycle and ContinuousAutoRate error handling tested"
    - "autorate_continuous.py overall coverage >= 90%"
  artifacts:
    - path: "tests/test_autorate_error_recovery.py"
      provides: "Error recovery path tests"
      min_lines: 250
    - path: "tests/test_wan_controller.py"
      provides: "Extended run_cycle coverage"
      min_lines: 500
  key_links:
    - from: "tests/test_autorate_error_recovery.py"
      to: "src/wanctl/autorate_continuous.py"
      via: "test error recovery paths in WANController and ContinuousAutoRate"
      pattern: "from wanctl.autorate_continuous import"
    - from: "tests/test_wan_controller.py"
      to: "src/wanctl/autorate_continuous.py"
      via: "extend run_cycle integration tests"
      pattern: "from wanctl.autorate_continuous import WANController"
---

<objective>
Test error recovery paths: RouterOS initialization, router failures, measurement failures, ICMP blackout with TCP RTT fallback, and graceful degradation modes.

Purpose: Creates test_autorate_error_recovery.py and extends test_wan_controller.py. Targets comprehensive coverage of failure handling code paths and RouterOS class (lines 526-574).

Output: New error recovery test file and extended run_cycle coverage in existing test file.
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-core-controller-tests/35-CONTEXT.md
@.planning/phases/35-core-controller-tests/35-01-SUMMARY.md
@.planning/phases/35-core-controller-tests/35-02-SUMMARY.md

@src/wanctl/autorate_continuous.py
@tests/test_wan_controller.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_autorate_error_recovery.py with fixtures and TestRouterOS class</name>
  <files>tests/test_autorate_error_recovery.py</files>
  <action>
Create test file with required imports and shared fixtures:

**Imports:**
- pytest, MagicMock, patch from unittest.mock
- WANController, ContinuousAutoRate, Config, RouterOS from wanctl.autorate_continuous

**Fixtures (copy pattern from test_wan_controller.py):**
- mock_config: Complete 30+ field config
- mock_router: Router with set_limits returning True by default
- mock_rtt_measurement: RTTMeasurement mock
- controller: WANController with patched load_state

Add TestRouterOS class (covers lines 526-574):

- test_routeros_init_calls_get_client_with_failover: Verifies get_router_client_with_failover called
- test_routeros_init_stores_config_and_logger: Config and logger attributes set
- test_routeros_set_limits_batches_commands: Both queues set in single SSH call
- test_routeros_set_limits_returns_false_on_failure: rc != 0 returns False
- test_routeros_set_limits_logs_error_on_failure: logger.error called with command
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_error_recovery.py --collect-only
  </verify>
  <done>
- tests/test_autorate_error_recovery.py exists with imports, fixtures, and TestRouterOS
- pytest can collect the module
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TestRouterFailureRecovery and TestMeasurementFailureRecovery classes</name>
  <files>tests/test_autorate_error_recovery.py</files>
  <action>
Add TestRouterFailureRecovery class with tests:

- test_router_failure_returns_false: run_cycle returns False when set_limits fails
- test_router_failure_does_not_update_tracking: last_applied rates unchanged on failure
- test_router_failure_logs_error: logger.error called with failure message
- test_router_failure_does_not_save_state: save_state not called after failure

Add TestMeasurementFailureRecovery class with tests:

- test_measurement_failure_invokes_fallback: handle_icmp_failure called when measure_rtt returns None
- test_measurement_failure_freeze_mode_saves_state: freeze mode returns True, saves state
- test_measurement_failure_use_last_rtt_continues: use_last_rtt mode uses load_rtt
- test_measurement_failure_graceful_degradation_sequence: Cycle 1=last_rtt, 2-3=freeze, 4+=fail

Use mock_router.set_limits.return_value = False and patch measure_rtt to return None.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_error_recovery.py::TestRouterFailureRecovery tests/test_autorate_error_recovery.py::TestMeasurementFailureRecovery -v
  </verify>
  <done>
- TestRouterFailureRecovery has 4 passing tests
- TestMeasurementFailureRecovery has 4 passing tests
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement TestIcmpTcpFallbackAndRecovery class</name>
  <files>tests/test_autorate_error_recovery.py</files>
  <action>
Add TestIcmpTcpFallbackAndRecovery class (consolidated from TcpRttFallback + IcmpRecoveryIntegration):

**TCP RTT fallback tests (v1.1.0 fix):**
- test_tcp_rtt_used_in_run_cycle: TCP RTT flows through to update_ewma when ICMP fails
- test_tcp_rtt_bypasses_graceful_degradation: Even at cycle 10, TCP RTT is used
- test_tcp_rtt_fallback_logs_warning: Warning logged about using TCP RTT

**ICMP recovery tests:**
- test_icmp_recovery_resets_counter: ICMP succeeds after failures, counter resets
- test_icmp_recovery_logs_info: Info message about recovery logged
- test_icmp_recovery_resumes_normal_operation: Normal EWMA updates resume

**Total connectivity loss tests:**
- test_total_loss_returns_false: Both ICMP and TCP fail, run_cycle returns False
- test_total_loss_logs_warning: Warning about total connectivity loss

Pattern: Simulate multiple ICMP failures, then recovery. Patch verify_connectivity_fallback.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_error_recovery.py::TestIcmpTcpFallbackAndRecovery -v
  </verify>
  <done>
- TestIcmpTcpFallbackAndRecovery has 8 passing tests
- TCP RTT fallback, ICMP recovery, and total connectivity loss verified
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement TestRunCycleErrorPaths class</name>
  <files>tests/test_autorate_error_recovery.py</files>
  <action>
Add TestRunCycleErrorPaths class with integration tests:

- test_run_cycle_saves_state_on_freeze: Freeze mode calls save_state
- test_run_cycle_does_not_save_on_failure: Router failure skips save_state
- test_run_cycle_periodic_force_save: Every FORCE_SAVE_INTERVAL_CYCLES, force=True
- test_run_cycle_rate_spike_forces_red: delta_accel > threshold forces RED state

Add TestContinuousAutoRateErrorHandling class:

- test_run_cycle_catches_lock_error: LockAcquisitionError returns False, logs debug
- test_run_cycle_catches_general_exception: Exception logged, returns False
- test_all_wans_success_required: Any WAN failure returns False

Use patch to inject exceptions at various points.
  </action>
  <verify>
.venv/bin/pytest tests/test_autorate_error_recovery.py::TestRunCycleErrorPaths tests/test_autorate_error_recovery.py::TestContinuousAutoRateErrorHandling -v
  </verify>
  <done>
- TestRunCycleErrorPaths has 4 passing tests
- TestContinuousAutoRateErrorHandling has 3 passing tests
  </done>
</task>

<task type="auto">
  <name>Task 5: Extend tests/test_wan_controller.py with run_cycle coverage</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Extend existing test_wan_controller.py:

Add to TestIcmpRecovery class:
- test_run_cycle_with_successful_rtt: Full cycle with good RTT measurement
- test_run_cycle_state_transition_logged: Info log contains zone and rates

Add new TestRunCycleMetrics class:
- test_run_cycle_records_metrics_when_enabled: record_autorate_cycle called
- test_run_cycle_skips_metrics_when_disabled: No metrics call when disabled
  </action>
  <verify>
.venv/bin/pytest tests/test_wan_controller.py::TestIcmpRecovery tests/test_wan_controller.py::TestRunCycleMetrics -v
  </verify>
  <done>
- TestIcmpRecovery extended with 2 new tests
- TestRunCycleMetrics class added with 2 tests
- run_cycle integration coverage extended
  </done>
</task>

</tasks>

<verification>
```bash
# Run new error recovery tests
.venv/bin/pytest tests/test_autorate_error_recovery.py -v

# Run extended test_wan_controller tests
.venv/bin/pytest tests/test_wan_controller.py -v

# Check overall autorate_continuous.py coverage
.venv/bin/pytest tests/test_autorate_*.py tests/test_wan_controller.py tests/test_queue_controller.py --cov=wanctl.autorate_continuous --cov-report=term-missing | tail -20
```
</verification>

<success_criteria>
- [ ] tests/test_autorate_error_recovery.py created with 24+ test methods
- [ ] TestRouterOS class covers RouterOS.__init__ and set_limits (lines 526-574)
- [ ] Router failure recovery tested
- [ ] Measurement failure fallback tested (all 3 modes)
- [ ] TCP RTT fallback tested (v1.1.0 fix verification)
- [ ] ICMP recovery tested (counter reset, normal operation resume)
- [ ] Total connectivity loss tested
- [ ] run_cycle error paths tested
- [ ] ContinuousAutoRate error handling tested
- [ ] test_wan_controller.py extended with run_cycle and metrics tests
- [ ] All tests pass with combined test run
- [ ] autorate_continuous.py coverage >= 90%
</success_criteria>

<output>
After completion, create `.planning/phases/35-core-controller-tests/35-03-SUMMARY.md`
</output>
