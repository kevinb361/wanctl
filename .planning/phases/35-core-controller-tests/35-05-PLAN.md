---
phase: 35-core-controller-tests
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_wan_controller.py
  - tests/test_autorate_error_recovery.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "verify_local_connectivity branches tested (gateway check enabled/disabled)"
    - "verify_tcp_connectivity full path tested (success, partial, all fail)"
    - "verify_connectivity_fallback all branches tested (tcp+gateway, gateway only, both fail)"
    - "load_state and save_state full paths tested"
    - "Rate limit branch and run_cycle failure path tested"
  artifacts:
    - path: "tests/test_wan_controller.py"
      provides: "Connectivity fallback and state persistence tests"
      contains: "connectivity|fallback|load_state|save_state"
    - path: "tests/test_autorate_error_recovery.py"
      provides: "Rate limit and run_cycle failure tests"
      contains: "rate_limit|run_cycle.*fail"
  key_links:
    - from: "tests/test_wan_controller.py"
      to: "WANController"
      via: "verify_connectivity_fallback, load_state, save_state"
      pattern: "verify_connectivity|load_state|save_state"
---

<objective>
Cover connectivity fallback paths, load/save state, and rate limiting branches.

Purpose: Close coverage gaps in lines 978-989, 1004-1077, 1119, 1246, 1330-1368
Output: Extended tests in test_wan_controller.py and test_autorate_error_recovery.py (~78 lines covered)
</objective>

<execution_context>
@/home/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/home/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/35-core-controller-tests/35-VERIFICATION.md

# Source code for uncovered lines
@src/wanctl/autorate_continuous.py (lines 970-1077: connectivity methods, lines 1117-1132: rate limit, lines 1236-1250: run_cycle failure, lines 1327-1385: load/save state)
</context>

<tasks>

<task type="auto">
  <name>Task 1: verify_local_connectivity tests</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Add tests for WANController.verify_local_connectivity():

1. Test fallback_check_gateway disabled (returns False immediately):
   - Set config.fallback_check_gateway=False
   - Verify method returns False without calling ping_host
   - Covers line 978-979

2. Test gateway reachable (returns True with warning):
   - Set config.fallback_check_gateway=True, fallback_gateway_ip="10.0.0.1"
   - Mock ping_host to return 5.0 (success)
   - Verify returns True
   - Verify logger.warning called with "gateway.*reachable"
   - Covers lines 981-988

3. Test gateway unreachable (returns False):
   - Mock ping_host to return None
   - Verify returns False
   - Covers line 989

Create TestVerifyLocalConnectivity class. Use controller_with_mocks fixture.
  </action>
  <verify>pytest tests/test_wan_controller.py -v -k "local_connectivity" passes</verify>
  <done>Lines 978-989 covered by verify_local_connectivity tests</done>
</task>

<task type="auto">
  <name>Task 2: verify_tcp_connectivity tests</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Add tests for WANController.verify_tcp_connectivity():

1. Test fallback_check_tcp disabled (returns (False, None)):
   - Set config.fallback_check_tcp=False
   - Verify returns (False, None) without attempting connections
   - Covers lines 1004-1005

2. Test all TCP targets succeed (returns (True, median_rtt)):
   - Set fallback_tcp_targets=[("1.1.1.1", 443), ("8.8.8.8", 443)]
   - Mock socket.create_connection to succeed with timing
   - Verify returns (True, median_rtt)
   - Verify logger.info with "TCP connectivity verified"
   - Covers lines 1007-1026

3. Test partial TCP success (1 of 2 succeed):
   - Mock first connection to succeed, second to raise TimeoutError
   - Verify returns (True, single_rtt)
   - Covers lines 1016-1018

4. Test all TCP fail (returns (False, None)):
   - Mock all connections to raise OSError
   - Verify returns (False, None)
   - Covers line 1028

Mock socket.create_connection. Use time.monotonic side_effect for RTT timing.
  </action>
  <verify>pytest tests/test_wan_controller.py -v -k "tcp_connectivity" passes</verify>
  <done>Lines 1004-1028 covered by verify_tcp_connectivity tests</done>
</task>

<task type="auto">
  <name>Task 3: verify_connectivity_fallback full branch tests</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Add tests for WANController.verify_connectivity_fallback() all branches:

1. Test fallback disabled (returns (False, None)):
   - Set config.fallback_enabled=False
   - Verify returns (False, None) immediately
   - Covers lines 1043-1044

2. Test TCP succeeds + gateway succeeds (ICMP filtering detected):
   - Mock verify_local_connectivity -> True
   - Mock verify_tcp_connectivity -> (True, 25.0)
   - Verify returns (True, 25.0)
   - Verify warning "ICMP filtering detected"
   - Covers lines 1055-1062

3. Test TCP succeeds + gateway fails:
   - Mock verify_local_connectivity -> False
   - Mock verify_tcp_connectivity -> (True, 25.0)
   - Verify returns (True, 25.0)
   - Covers lines 1055-1062 (different branch)

4. Test TCP fails + gateway succeeds (partial connectivity):
   - Mock verify_local_connectivity -> True
   - Mock verify_tcp_connectivity -> (False, None)
   - Verify returns (True, None)
   - Verify warning "gateway reachable"
   - Covers lines 1064-1070

5. Test both fail (total connectivity loss):
   - Mock verify_local_connectivity -> False
   - Mock verify_tcp_connectivity -> (False, None)
   - Verify returns (False, None)
   - Verify error "confirmed total connectivity loss"
   - Covers lines 1072-1077

Create TestVerifyConnectivityFallback class.
  </action>
  <verify>pytest tests/test_wan_controller.py -v -k "connectivity_fallback" passes</verify>
  <done>Lines 1043-1077 covered by verify_connectivity_fallback tests</done>
</task>

<task type="auto">
  <name>Task 4: load_state and save_state full path tests</name>
  <files>tests/test_wan_controller.py</files>
  <action>
Add tests for WANController.load_state() and save_state() full paths:

1. Test load_state with full state dict:
   - Create state dict with download, upload, ewma, last_applied sections
   - Mock state_manager.load() to return full state
   - Call load_state()
   - Verify all fields restored: green_streak, soft_red_streak, red_streak, current_rate
   - Verify ewma restored: baseline_rtt, load_rtt
   - Verify last_applied restored: dl_rate, ul_rate
   - Covers lines 1330-1359

2. Test load_state with partial state (some sections missing):
   - Return state with only "download" section
   - Verify download restored, others use defaults

3. Test save_state calls state_manager.save:
   - Mock state_manager.save
   - Call save_state()
   - Verify save called with correct structure
   - Covers line 1368

4. Test save_state with force=True:
   - Call save_state(force=True)
   - Verify force passed to state_manager.save

Create TestStateLoadSave class.
  </action>
  <verify>pytest tests/test_wan_controller.py -v -k "state" passes</verify>
  <done>Lines 1330-1368 covered by load_state and save_state tests</done>
</task>

<task type="auto">
  <name>Task 5: Rate limit branch and run_cycle failure tests</name>
  <files>tests/test_autorate_error_recovery.py</files>
  <action>
Add tests for rate limit branch and run_cycle failure path:

1. Test rate limit active (throttles update):
   - Mock rate_limiter.can_change() -> False
   - Mock rate_limiter.time_until_available() -> 5.0
   - Set _rate_limit_logged=False
   - Call apply_rate_changes_if_needed
   - Verify returns True (cycle success, just throttled)
   - Verify save_state called
   - Verify _rate_limit_logged set True
   - Verify logger.debug with "Rate limit active"
   - Covers lines 1119-1132

2. Test rate limit already logged (no duplicate log):
   - Set _rate_limit_logged=True before call
   - Verify debug NOT called again

3. Test run_cycle returns False on handle_icmp_failure failure:
   - Mock measure_rtt -> None
   - Mock handle_icmp_failure -> (False, None)
   - Call run_cycle()
   - Verify returns False
   - Covers line 1246

Add to existing TestContinuousAutoRateErrors class or create TestRateLimitBranch.
  </action>
  <verify>pytest tests/test_autorate_error_recovery.py -v -k "rate_limit or run_cycle_fail" passes</verify>
  <done>Lines 1119-1132 and 1246 covered by rate limit and run_cycle tests</done>
</task>

</tasks>

<verification>
```bash
# Run all new tests
pytest tests/test_wan_controller.py tests/test_autorate_error_recovery.py -v -k "connectivity or state or rate_limit"

# Verify coverage improvement
pytest tests/ --cov=wanctl.autorate_continuous --cov-report=term-missing -q 2>&1 | grep "autorate_continuous"
# Expect: lines 978-1077, 1119, 1246, 1330-1368 no longer in missing list
```
</verification>

<success_criteria>
- Lines 978-989 (verify_local_connectivity) covered
- Lines 1004-1028 (verify_tcp_connectivity) covered
- Lines 1043-1077 (verify_connectivity_fallback) covered
- Lines 1119-1132 (rate limit branch) covered
- Line 1246 (run_cycle failure) covered
- Lines 1330-1368 (load_state, save_state) covered
- All tests pass with `pytest -v`
- Coverage improved by ~78 lines (78% -> ~89%)
</success_criteria>

<output>
After completion, create `.planning/phases/35-core-controller-tests/35-05-SUMMARY.md`
</output>
