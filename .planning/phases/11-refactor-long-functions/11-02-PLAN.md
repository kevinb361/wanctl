---
phase: 11-refactor-long-functions
plan: 02
type: execute
---

<objective>
Split run_calibration() (236 lines) into focused step methods for improved readability.

Purpose: Break down the monolithic calibration wizard into testable, maintainable step functions.
Output: run_calibration() as orchestrator calling 6 step methods matching the existing Step 1-6 structure.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source file to refactor:
@src/wanctl/calibrate.py

**Current structure:**
run_calibration() has 6 explicit steps marked with print_header():
- Step 1: Connectivity Tests (lines 619-638)
- Step 2: Baseline RTT Measurement (lines 640-661)
- Step 3: Raw Throughput Measurement (lines 663-698)
- Step 4: Binary Search for Optimal Rates (lines 700-757)
- Step 5: Results Summary (lines 781-790)
- Step 6: Generate Configuration (lines 792-813)

**Refactoring approach:**
Extract each step into a dedicated method that returns success/failure and any computed values.
run_calibration() becomes orchestrator that calls steps in sequence.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract calibration steps 1-4 into helper methods</name>
  <files>src/wanctl/calibrate.py</files>
  <action>
Extract the first four steps from run_calibration() into module-level helper functions:

1. `_step_connectivity_tests(router_host, router_user, ssh_key, netperf_host) -> tuple[bool, bool]`
   - Returns (success, skip_throughput)
   - Lines 619-638: SSH test, netperf test
   - Handles shutdown check after connectivity test

2. `_step_baseline_rtt(ping_host) -> Optional[float]`
   - Returns baseline_rtt or None on failure
   - Lines 640-661: measure_baseline_rtt, connection type detection
   - Handles shutdown check after measurement

3. `_step_raw_throughput(netperf_host, ping_host, baseline_rtt, skip_throughput) -> tuple[float, float, float, float]`
   - Returns (raw_download, raw_upload, download_bloat, upload_bloat)
   - Lines 663-698: download/upload throughput measurement
   - Handles shutdown checks and skip_throughput fallback

4. `_step_binary_search(netperf_host, ping_host, router_host, router_user, download_queue, upload_queue, raw_download, raw_upload, baseline_rtt, target_bloat, ssh_key, skip_binary_search, skip_throughput) -> tuple[float, float, float, float]`
   - Returns (optimal_download, optimal_upload, download_bloat, upload_bloat)
   - Lines 700-757: binary search or 90% fallback
   - Handles shutdown checks and queue reset on interrupt

Each helper:
- Has clear input parameters and return type
- Handles its own shutdown checks (return None or raise on interrupt)
- Uses existing print_* functions for output
- Does NOT change any behavior - pure extraction
  </action>
  <verify>python -c "from wanctl.calibrate import run_calibration; print('Import OK')"</verify>
  <done>Steps 1-4 extracted as helper functions, run_calibration() calls them</done>
</task>

<task type="auto">
  <name>Task 2: Extract steps 5-6 and verify calibration workflow</name>
  <files>src/wanctl/calibrate.py</files>
  <action>
Extract remaining steps and verify the complete refactoring:

5. `_step_display_summary(result: CalibrationResult) -> None`
   - Lines 781-790: print results summary
   - Pure display, no return value

6. `_step_save_results(result: CalibrationResult, output_dir: str) -> bool`
   - Lines 792-813: generate_config call, save JSON results, print next steps
   - Returns True on success

Refactored run_calibration() becomes:
```python
def run_calibration(...) -> Optional[CalibrationResult]:
    print_header(f"wanctl Calibration - {wan_name}")

    # Default queue names
    if not download_queue:
        download_queue = f"WAN-Download-{wan_name.capitalize()}"
    if not upload_queue:
        upload_queue = f"WAN-Upload-{wan_name.capitalize()}"

    # Step 1: Connectivity
    success, skip_throughput = _step_connectivity_tests(...)
    if not success:
        return None

    # Step 2: Baseline RTT
    baseline_rtt = _step_baseline_rtt(ping_host)
    if baseline_rtt is None:
        return None

    # Step 3: Raw throughput
    raw_dl, raw_ul, dl_bloat_raw, ul_bloat_raw = _step_raw_throughput(...)
    if raw_dl is None:  # interrupted
        return None

    # Step 4: Binary search
    opt_dl, opt_ul, dl_bloat, ul_bloat = _step_binary_search(...)
    if opt_dl is None:  # interrupted
        return None

    # Build result
    result = CalibrationResult(...)

    # Step 5: Summary
    _step_display_summary(result)

    # Step 6: Save
    _step_save_results(result, output_dir)

    return result
```

Run full test suite to verify no behavioral changes:
- `make ci` must pass
- Calibration workflow unchanged
  </action>
  <verify>make ci</verify>
  <done>All 6 steps extracted, run_calibration() is orchestrator, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] run_calibration() reduced from 236 lines to ~50 lines of orchestration
- [ ] 6 step helper functions created with clear responsibilities
- [ ] `make ci` passes (all tests, type check, lint)
- [ ] Calibration workflow behavior unchanged
</verification>

<success_criteria>

- run_calibration() is now orchestration-only (~50 lines)
- 6 step functions match the Step 1-6 structure in the code
- All tests pass
- No type errors or lint warnings
- Calibration can still be run end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/11-refactor-long-functions/11-02-SUMMARY.md`
</output>
