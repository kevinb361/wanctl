---
phase: 15-steeringdaemon-refactoring
plan: 05
type: execute
---

<objective>
Unify CAKE-aware and legacy state machine methods into single implementation.

Purpose: Eliminate ~60% code duplication between state machine methods while preserving exact behavioral semantics. Enables easier maintenance and future mode additions.
Output: Unified _update_state_machine() with mode-specific condition evaluation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 7 analysis (S6 recommendation - HIGH RISK)
@.planning/phases/07-core-algorithm-analysis/07-02-steeringdaemon-findings.md
@docs/CORE-ALGORITHM-ANALYSIS.md

# Source files
@src/wanctl/steering/daemon.py

# Prior plan (routing extraction prerequisite)
@.planning/phases/15-steeringdaemon-refactoring/15-03-SUMMARY.md

**Tech stack available:** Python 3.12, pytest
**Established patterns:** execute_steering_transition() from 15-03
**Constraining decisions:**
- Phase 7: S6 identified as HIGH risk (touches PROTECTED zone)
- Asymmetric hysteresis MUST be preserved exactly
- Counter semantics: red_count (CAKE) vs bad_count (legacy) must both work
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified state machine implementation</name>
  <files>src/wanctl/steering/daemon.py</files>
  <action>
Refactor _update_state_machine_cake_aware() and _update_state_machine_legacy() into unified implementation.

Create helper for mode-specific condition evaluation:

```python
def _evaluate_degradation_condition(
    self,
    signals: CongestionSignals
) -> tuple[bool, bool, str | None]:
    """
    Evaluate degradation/recovery conditions based on mode.

    Returns:
        tuple[bool, bool, str | None]: (is_degraded, is_recovered, assessment_value)
        assessment_value is CongestionState value for CAKE mode, None for legacy
    """
    if self.config.cake_aware:
        assessment = assess_congestion_state(signals, self.thresholds, self.logger)
        return (
            assessment == CongestionState.RED,
            assessment == CongestionState.GREEN,
            assessment.value
        )
    else:
        return (
            signals.rtt_delta > self.config.bad_threshold_ms,
            signals.rtt_delta < self.config.recovery_threshold_ms,
            None
        )
```

Create unified state machine:

```python
def _update_state_machine_unified(self, signals: CongestionSignals) -> bool:
    """
    Unified state machine for both CAKE-aware and legacy modes.

    PROTECTED: Asymmetric hysteresis - quick to enable, slow to disable.
    Do not change thresholds without production validation.
    See docs/CORE-ALGORITHM-ANALYSIS.md.
    """
```

The unified method should:
1. Call _evaluate_degradation_condition() for mode-specific logic
2. Use execute_steering_transition() from 15-03 for routing
3. Handle counter aliases: degrade_count (was red_count/bad_count), recover_count (was good_count)
4. Preserve all logging behavior
5. Store congestion_state for observability (CAKE mode only)

Update update_state_machine() to call unified implementation.
Keep old methods as deprecated aliases initially for safety.
  </action>
  <verify>make ci passes (all tests)</verify>
  <done>Unified state machine implemented, both modes work, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive state machine tests</name>
  <files>tests/test_steering_daemon.py</files>
  <action>
Add comprehensive tests verifying behavioral equivalence:

CAKE-aware mode tests:
1. RED assessment increments degrade_count
2. GREEN assessment increments recover_count
3. YELLOW resets degrade_count (no action)
4. Transition to DEGRADED after red_samples_required RED cycles
5. Transition to GOOD after green_samples_required GREEN cycles

Legacy mode tests:
6. High delta increments degrade_count
7. Low delta increments recover_count
8. Transition to DEGRADED after bad_samples exceeded
9. Transition to GOOD after good_samples exceeded

Cross-mode tests:
10. Counter reset on state change
11. State normalization (legacy names handled)
12. Metrics recorded on transition

Use parameterized tests where possible to reduce duplication.
  </action>
  <verify>pytest tests/test_steering_daemon.py -v passes with new tests</verify>
  <done>12+ tests added, both modes verified behaviorally equivalent</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Unified state machine replacing CAKE-aware and legacy implementations</what-built>
  <how-to-verify>
    1. Run: make ci (all 540+ tests should pass)
    2. Review: git diff src/wanctl/steering/daemon.py
    3. Verify: Both modes still work identically:
       - CAKE-aware: assessment-based (RED/GREEN triggers)
       - Legacy: threshold-based (delta comparison)
    4. Verify: Counter semantics preserved (asymmetric hysteresis)
    5. Verify: All logging behavior unchanged
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (all tests including new ones)
- [ ] Unified state machine handles both modes
- [ ] PROTECTED zone comment preserved
- [ ] Asymmetric hysteresis verified (quick degrade, slow recover)
- [ ] User approved behavioral equivalence
</verification>

<success_criteria>
- State machine methods unified (~70 lines saved)
- Both CAKE-aware and legacy modes work identically
- All tests pass
- User verified no behavioral changes
</success_criteria>

<output>
After completion, create `.planning/phases/15-steeringdaemon-refactoring/15-05-SUMMARY.md`
</output>
