---
phase: 15-steeringdaemon-refactoring
plan: 06
type: execute
---

<objective>
Integrate Phase2BController confidence scoring alongside existing hysteresis logic.

Purpose: Enable confidence-based steering decisions with multi-signal scoring, sustain timers, and flap detection. Uses config flag for gradual rollout with dry-run validation.
Output: Phase2BController integration with config flag and dry-run mode.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 7 analysis (S7 recommendation - HIGH RISK)
@.planning/phases/07-core-algorithm-analysis/07-02-steeringdaemon-findings.md
@docs/CORE-ALGORITHM-ANALYSIS.md

# Source files
@src/wanctl/steering/daemon.py
@src/wanctl/steering/steering_confidence.py

**Tech stack available:** Python 3.12, pytest, Phase2BController (643 lines, untested in production)
**Established patterns:** Config flags for gradual rollout
**Constraining decisions:**
- Phase 7: S7 identified as HIGH risk (behavioral change)
- Dry-run mode MUST be default (log-only, no routing changes)
- Existing hysteresis must remain functional
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add confidence scoring config section</name>
  <files>src/wanctl/steering/daemon.py, src/wanctl/config_validation_utils.py</files>
  <action>
Add new config section to SteeringConfig for Phase 2B integration:

```python
# In _load_specific_fields() or new _load_confidence_config() helper:

# Confidence scoring mode (Phase 2B)
mode = self.data.get('mode', {})
self.use_confidence_scoring = mode.get('use_confidence_scoring', False)

if self.use_confidence_scoring:
    confidence = self.data.get('confidence', {})
    self.confidence_config = {
        'confidence': {
            'steer_threshold': confidence.get('steer_threshold', 55),
            'recovery_threshold': confidence.get('recovery_threshold', 20),
            'sustain_duration_sec': confidence.get('sustain_duration_sec', 2.0),
            'recovery_sustain_sec': confidence.get('recovery_sustain_sec', 3.0),
        },
        'timers': {
            'hold_down_duration_sec': confidence.get('hold_down_duration_sec', 30.0),
        },
        'flap_detection': {
            'enabled': confidence.get('flap_detection_enabled', True),
            'window_minutes': confidence.get('flap_window_minutes', 5),
            'max_toggles': confidence.get('max_toggles', 4),
            'penalty_duration_sec': confidence.get('penalty_duration_sec', 60.0),
            'penalty_threshold_add': confidence.get('penalty_threshold_add', 15),
        },
        'dry_run': {
            'enabled': confidence.get('dry_run', True),  # DEFAULT TRUE
        },
    }
```

Add validation for confidence thresholds (0-100 range).
Default dry_run=True ensures safe initial deployment.
  </action>
  <verify>make ci passes, config loads without errors</verify>
  <done>Confidence config section added with validation, dry_run defaults to True</done>
</task>

<task type="auto">
  <name>Task 2: Initialize Phase2BController in SteeringDaemon</name>
  <files>src/wanctl/steering/daemon.py</files>
  <action>
Add Phase2BController initialization to SteeringDaemon.__init__():

```python
from .steering_confidence import Phase2BController, ConfidenceSignals as Phase2BSignals

# In __init__():
self.confidence_controller: Phase2BController | None = None
if self.config.use_confidence_scoring:
    self.confidence_controller = Phase2BController(
        config_v3=self.config.confidence_config,
        logger=self.logger,
        state_good=self.config.state_good,
        state_degraded=self.config.state_degraded
    )
    self.logger.info(
        f"[PHASE2B] Confidence scoring enabled "
        f"(dry_run={self.config.confidence_config['dry_run']['enabled']})"
    )
```

Add parallel evaluation in update_state_machine():

```python
def update_state_machine(self, signals: CongestionSignals) -> bool:
    # If confidence controller enabled, evaluate in parallel
    if self.confidence_controller:
        # Convert signals for Phase2B
        phase2b_signals = Phase2BSignals(
            cake_state=self.state_mgr.state.get('congestion_state', 'GREEN'),
            rtt_delta_ms=signals.rtt_delta,
            drops_per_sec=signals.cake_drops,
            queue_depth_pct=float(signals.queued_packets),  # Simplified
            cake_state_history=list(self.state_mgr.state.get('congestion_history', [])),
            drops_history=list(self.state_mgr.state.get('cake_drops_history', [])),
            queue_history=list(self.state_mgr.state.get('queue_depth_history', [])),
        )

        # Evaluate (returns decision or None if dry-run)
        confidence_decision = self.confidence_controller.evaluate(
            phase2b_signals,
            self.state_mgr.state['current_state']
        )

        # In dry-run mode, log decision but use hysteresis
        # In live mode, use confidence decision
        if confidence_decision and not self.config.confidence_config['dry_run']['enabled']:
            return self._apply_confidence_decision(confidence_decision)

    # Fall through to existing hysteresis logic
    if self.config.cake_aware:
        return self._update_state_machine_cake_aware(signals)
    else:
        return self._update_state_machine_legacy(signals.rtt_delta)
```

Add _apply_confidence_decision() helper for routing control.
  </action>
  <verify>make ci passes with confidence controller</verify>
  <done>Phase2BController initialized, parallel evaluation working, dry-run logs decisions</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Phase2BController integration with dry-run mode (log-only by default)</what-built>
  <how-to-verify>
    1. Run: make ci (all tests should pass)
    2. Create test config with use_confidence_scoring: true
    3. Run daemon locally for 2-3 minutes
    4. Verify logs show:
       - "[PHASE2B] Controller initialized"
       - "[PHASE2B] Confidence=XX signals=[...]" on each cycle
       - "[PHASE2B][DRY-RUN] WOULD_ENABLE/WOULD_DISABLE" when thresholds crossed
    5. Verify: NO actual routing changes occur (dry-run mode)
    6. Verify: Hysteresis logic still makes actual decisions
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `make ci` passes (all tests)
- [ ] use_confidence_scoring config flag works
- [ ] dry_run defaults to True (safe default)
- [ ] Phase2BController logs confidence scores each cycle
- [ ] No routing changes in dry-run mode
- [ ] User verified dry-run behavior
</verification>

<success_criteria>
- Phase2BController integrated alongside hysteresis
- Config flag enables/disables confidence scoring
- Dry-run mode logs decisions without routing changes
- Existing hysteresis behavior unchanged when confidence disabled
- User verified safe deployment path
</success_criteria>

<output>
After completion, create `.planning/phases/15-steeringdaemon-refactoring/15-06-SUMMARY.md`

Note: After this plan, production validation requires:
1. Deploy with dry_run=true for 1 week
2. Compare confidence decisions vs hysteresis decisions
3. Set dry_run=false to enable confidence-based routing
4. Monitor for flapping or unexpected behavior
</output>
